{"C":{"path":"../../src/c","header":{"compile.h":"#ifndef __COMPILE_H\n#define __COMPILE_H\nextern sb2 compileToken(ub1  *code,sb2 position, ub2 *pc);\nextern sb2 compile(ub1 *code,sb2 position, ub2 *pc);\n#endif\n","dict.h":"#ifndef __DICT_H\n#define __DICT_H\n#include \"standard.h\"\n#define DICTNAMELENGTH  8\nstruct dict_cell {\n   char name[DICTNAMELENGTH];\n   ub2  addr;\n   ub2  size;\n   ub1  flags;\n};\n#define ALLOCATE  0x01\n#define ARRAY     0x02\n#define INDIRECT  0x04\n\ntypedef struct dict_cell dict_cell_t;\nextern dict_cell_t dictionary[DICTSIZE];\nextern ub2 dictcollision;\nextern ub2 dicthash(char *name, ub2 length);\nextern ub2 dictlookup(char *name, ub2 length);\nextern ub2 dictadd(char *name, ub2 length);\nextern ub2 dictrem(char *name, ub2 length);\n#define NOTFOUND 0xFFFF\n#endif\n\n","diss.h":"#ifndef __DISS_H\n#define __DISS_H\nextern void disassemble(ub2 start, ub2 end);\n#endif\n\n","lookupa.h":"/*\n------------------------------------------------------------------------------\nBy Bob Jenkins, September 1996.\nlookupa.h, a hash function for table lookup, same function as lookup.c.\nUse this code in any way you wish.  Public Domain.  It has no warranty.\nSource is http://burtleburtle.net/bob/c/lookupa.h\n------------------------------------------------------------------------------\n*/\n\n#ifndef STANDARD\n#include \"standard.h\"\n#endif\n\n#ifndef LOOKUPA\n#define LOOKUPA\n\n#define CHECKSTATE 8\n#define hashsize(n) ((ub4)1<<(n))\n#define hashmask(n) (hashsize(n)-1)\n\nub4  lookup(/*_ ub1 *k, ub4 length, ub4 level _*/);\nvoid checksum(/*_ ub1 *k, ub4 length, ub4 *state _*/);\n\n#endif /* LOOKUPA */\n","lookupl.h":"#ifndef _LOOKUPLST_H\n#define _LOOKUPLST_H\nextern ub1 lookupLST (char *word, ub2 len, ub1 *table);\n#endif\n","stack.h":"#ifndef __STACK_H\n#include \"standard.h\"\nextern sb2 DS[];\nextern sb2 RS[];\nextern sb2 FS[];\nextern ub2 dstop; // data stack segment pointer\nextern ub2 rstop; // return stack segment pointer\n// TODO: merge rs and fs stacks;\nextern ub2 fstop; // loop stack segment pointer\n// Long number (double word) storage depends on CPU endianess: Little Endian. LSW MSW -- or Bif Endian. MSW LSW --\n#define POP()       DS[(dstop--)-1]\n#define POP2()      (*(sb4*)(&DS[dstop-=2]))\n#define POP2U()     (*(ub4*)(&DS[dstop-=2]))\n#define RPOP()      RS[(rstop--)-1]\n#define RPOP2()     (*(sb4*)(&RS[rstop-=2]))\n#define FPOP()      FS[(fstop--)-1]\n#define FPOP2()     (*(sb4*)(&FS[fstop-=2]))\n#define PUSH(v)     DS[dstop++]=v;\n#define PUSH2(v)    *(sb4*)(&DS[dstop])=v; dstop+=2;\n#define RPUSH(v)    RS[rstop++]=v;\n#define RPUSH2(v)   *(sb4*)(&RS[rstop])=v; rstop+=2;\n#define FPUSH(v)     FS[fstop++]=v;\n#define FPUSH2(v)    *(sb4*)(&FS[fstop])=v; fstop+=2;\n#define FPUSH2U(v)   *(ub4*)(&FS[fstop])=(ub4)v; fstop+=2;\n#define STACKTOP(n)  DS[dstop-n]\n#define FSTACKTOP(n) FS[fstop-n]\n#define RSTACKTOP(n) DS[dstop-n]\n#define STACKTOP2(n) (*(sb4*)(&DS[dstop-n-1]))\n#define STACKCHECK(n)   if (n>dstop) { vmerror=ESTACK; goto onerror; }\n#define FSTACKCHECK(n)  if (n>fstop) { vmerror=ESTACK; goto onerror; }\n#define RSTACKCHECK(n)  if (n>rstop) { vmerror=ERSTACK; goto onerror; }\n#define DEBUGSS() {int i;for(i=0;i<dstop;i++) printf(\" %x \",DS[i]); printf(\"\\n\"); }\n\n#endif\n","standard.h":"/*\n------------------------------------------------------------------------------\nStandard definitions and types, Bob Jenkins\n------------------------------------------------------------------------------\n*/\n#ifndef STANDARD\n# define STANDARD\n# ifndef STDIO\n#  include <stdio.h>\n#  define STDIO\n# endif\n# ifndef STDDEF\n#  include <stddef.h>\n#  define STDDEF\n# endif\n# ifndef STDLUIB\n#   include <stdlib.h>\n#   define STDLIB\n# endif\n# ifndef STDSTRING\n#    include <string.h>\n#    define STDSTRING\n# endif\ntypedef  unsigned long long  ub8;\n#define UB8MAXVAL 0xffffffffffffffffLL\n#define UB8BITS 64\ntypedef    signed long long  sb8;\n#define SB8MAXVAL 0x7fffffffffffffffLL\ntypedef  unsigned long  int  ub4;   /* unsigned 4-byte quantities */\n#define UB4MAXVAL 0xffffffff\ntypedef    signed long  int  sb4;\n#define UB4BITS 32\n#define SB4MAXVAL 0x7fffffff\ntypedef  unsigned short int  ub2;\n#define UB2MAXVAL 0xffff\n#define UB2BITS 16\ntypedef    signed short int  sb2;\n#define SB2MAXVAL 0x7fff\ntypedef  unsigned       char ub1;\n#define UB1MAXVAL 0xff\n#define UB1BITS 8\ntypedef    signed       char sb1;   /* signed 1-byte quantities */\n#define SB1MAXVAL 0x7f\ntypedef                 int  word;  /* fastest type available */\n\n#define bis(target,mask)  ((target) |=  (mask))\n#define bic(target,mask)  ((target) &= ~(mask))\n#define bit(target,mask)  ((target) &   (mask))\n#ifndef min\n# define min(a,b) (((a)<(b)) ? (a) : (b))\n#endif /* min */\n#ifndef max\n# define max(a,b) (((a)<(b)) ? (b) : (a))\n#endif /* max */\n#ifndef align\n# define align(a) (((ub4)a+(sizeof(void *)-1))&(~(sizeof(void *)-1)))\n#endif /* align */\n#ifndef abs\n# define abs(a)   (((a)>0) ? (a) : -(a))\n#endif\n#define TRUE  1\n#define FALSE 0\n#define SUCCESS 0  /* 1 on VAX */\n\n#endif /* STANDARD */\n","vm.h":"#ifndef __VM_H\n#define __VM_H\n#include \"standard.h\"\n#include \"dict.h\"\n\n#define VMVERSION \"0.19.1\"\n\n#define BIGENDUB2(v)   (((v&0xFF)<<8)|((v>>8)&0xFF))\n#define STORELIT(code,pc,v) { code[pc]=(v>>8)&0x3F; code[pc+1]=v&0xFF; }\n\nextern ub1 vmerror;\nextern void vmraiseerror(ub1);\n\nenum VMERRORS {\n  EOK,\n  ENOTFOUND,\n  ESTACK,\n  ERSTACK,\n  EPC,\n  ESYNTAX,\n  ESYNTAXNUM,\n  ESYNTAXENV,\n  EINDEX,\n  EFCALL,\n  EIO,\n  ENOTIMPLEMENTED,\n  EDATA\n};\nenum VMSTATES {\n  VMIDLE  = 0x00,\n  VMRUN   = 0x01,\n  VMEND   = 0x10,\n  VMERROR = 0x20,\n  VMSUSPEND = 0x40,\n};\n\n#ifdef MULTITASKING\nstruct frame_s {\n  sb2 bottom;\n  sb2 top;\n  sb2 next;\n  ub1 flags;\n};\ntypedef struct frame_s frame_t;\nextern frame_t frames[FRAMES];\n#endif\n\n// Event handler\nstruct vmevent_s {\n  ub4 timeout;\n  ub2 *v;\n  ub2  c;\n};\ntypedef struct vmevent_s vmevent_t;\n\n#ifdef MULTITASKING\n  struct vmtask_s {\n    ub4 timeout;\n    ub2 *v;\n    ub2  c;\n    ub2 pc;\n    ub2 dstop;\n    ub2 rstop;  \n    ub2 fstop;\n  }\n  typedef struct vmtask_s vmtask_t;\n  extern vmtask_t vmtasks[MAXTASKS];\n  #define TASKREADY   0b11111111111111111111111111111111l\n  #define TASKTIMEOUT 0b01010101010101010101010101010101l\n  #define TASKEVENT   0b10101010101010101010101010101010l\n  // [TM15|TM14|..|TM0]\n  // TM: 00:empty; 01:awaiting timeout 10:awaiting event, 11:ready\n  // Up to 16 tasks\n  extern ub4        vmtaskmask;\n  // Thread table\n  extern ub1        vmtaskcurrent;\n#else\n  // only one \"task\"\n  extern vmevent_t  vmevent;\n#endif\n\n// shared by all tasks, threads, and compiler (and comm. IO)\nextern ub1  CS[CODESIZE];\nextern ub2 cstop; // code sgement pointer\nextern ub2 frtop; // frame table index pointer\nextern sb2 pctop; // current PC\nextern ub1 vmerror;  // error code\nextern ub1 vmstate;  // vm state\nextern ub1 vmbase;   // number base 0:d/1:h/2:b\n\n \nextern void vmreset(void);\n// Return 0: normal exit, <0: error code, >0: timeout in milli seconds\nextern sb2 vmrun(ub2 steps);\n#endif\n","vmio.h":"#ifndef __VMIO_H\n#define __VMIO_H\n\n#define DICTNAMELENGTH  8\n\nstruct ios {\n  char name[DICTNAMELENGTH+1];\n  union {\n    void *callback;\n    void *data;\n  };\n  char  type;\n  union {\n    ub2  cells;\n    ub1  args;\n  };\n  union {\n    ub1  size;\n    ub1  argsize;\n  };\n  ub1 retsize;\n};\ntypedef struct ios ios_t;\n\n#define IOSCALLBACK(f) (void (*)())&f\n#define IOSCALLBACKPTR(p) (void (*)())p\n#define IOSDATA(d) (void *)d\n\nextern ub1 iostop;\nextern ios_t ios[];\nextern void iosInit(void);\nextern ub1 fiosAdd(char *name, void (*callback)(), ub1 args, ub1 argsize, ub1 retsize);\nextern ub1 diosAdd(char *name, void *data, ub2 cells, ub1 size);\nextern ub4 vmMilli(void);\n\n#define FIOSCALL0(index,...) (*(void (*)())ios[index].callback)(__VA_ARGS__)\n#define FIOSCALL1(index,...) (*(ub1 (*)())ios[index].callback)(__VA_ARGS__)\n#define FIOSCALL2(index,...) (*(ub2 (*)())ios[index].callback)(__VA_ARGS__)\n#define FIOSCALL4(index,...) (*(ub4 (*)())ios[index].callback)(__VA_ARGS__)\n#define DIOSARRAYINDEX(type,index,offset)  (((type* )ios[index].data)[offset])\n#define DIOSDATADEREF(type,index)          (*((type* )ios[index].data))\n#define DIOSDATADPTR(type,index)           ((type* )ios[index].data)\n#endif\n\n","vmloop.h":"#ifndef __VMLOOP_H\n#define __VMLOOP_H\n#include \"vmcode.h\"\n#define DECODE(word) (word&0x80?word&0x7F:word&0x40?OP_TWOLIT:OP_LIT)\n#if VMLOOP==COMPUTEDGOTO\n  #define DISPATCH() PROFILER DEBUG(\"pc=%x ds=%d rs=%d fs=%d op=%x id=%d\\n\",pc,dstop,rstop,fstop,code[pc],DECODE(code[pc])); if ((--steps)==0) goto schedule; goto *dispatch_table[DECODE(code[pc])]\n#endif\n#if VMLOOP==SWITCHCASE\n  #define DISPATCH() PROFILER DEBUG(\"pc=%x ds=%d rs=%d fs=%d op=%x id=%d\\n\",pc,dstop,rstop,fstop,code[pc],DECODE(code[pc])); if ((--steps)==0) goto schedule; break\n#endif\n#if VMLOOP==SWITCHCASEGOTO\n  #define DISPATCH() PROFILER DEBUG(\"pc=%x ds=%d rs=%d fs=%d op=%x id=%d\\n\",pc,dstop,rstop,fstop,code[pc],DECODE(code[pc])); if ((--steps)==0) goto schedule; goto dispatch\n#endif\n#if VMLOOP==FUNCTABLE\n  #define DISPATCH() PROFILER DEBUG(\"pc=%x ds=%d rs=%d fs=%d op=%x id=%d\\n\",pc,dstop,rstop,fstop,code[pc],DECODE(code[pc])); if ((--steps)==0) goto schedule;\n#endif\n#define EXTENDSIGN(v) (v&0x20?v|0xC0:v)\n\n// Main VM loop executing code.\n// Code: CS or any other buffer, pc: CS offset address, steps: maximal number of steps\n// Returns current (next) pc value; if a negative value is returned, then the current op is suspended (e.g., sleep)\n// The vmevent.timeout fields > 0 is the next time when the vmloop may be reentered.\n// If (ub4) vmevent.v is not null, the vmloop may be reentered only if *v==vmevent.c is satisfied\n// if an error occured, vmerror contains the error code\nextern sb2 vmloop(ub1* code, ub2 pc, ub2 steps);\n#endif\n\n"},"source":{"compile.c":"#include \"config.h\"\n#include \"standard.h\"\n#ifdef PHLEXER\n#include \"corehash.h\"\n#include \"lookupa.h\"\n#endif\n#ifdef LSTLEXER\n#include \"vmwords.h\"\n#include \"lookupl.h\"\n#endif\n#include \"vm.h\"\n#include \"vmcode.h\"\n#include \"dict.h\"\n#include \"stack.h\"\n#include \"vmio.h\"\n#include \"compile.h\"\n#include <string.h>\n\n#define ISSEP(c)                (c==' ' || c==0 || c=='\\n')\n#define ISNUM(c)                (c>='0' && c<='9')\n#define SKIPSEP(code,position)  while(ISSEP(code[position])) position++\n#define SKIPSEPCOMMENT(code,position)  { \\\n  ub1 incomm=0;\\\n  while(ISSEP(code[position]) || code[position]=='(' || incomm) {\\\n   if (incomm && code[position]==')') incomm=0;\\\n   else if (!incomm && code[position]=='(') incomm=1;\\\n   position++;\\\n}}\n#define SKIPCOMMENT(code,position)  if (code[position]=='(') { while(code[position] && code[position]!=')') position++; return position+1; }\n#define STORESB2(code,pc,v)     *(sb2*)(&code[pc])=v;\n\n#ifdef WORDSTRINGS\nOPSTRTABLEGEN\n#endif\n\n/* \n\n  Byetcode compilation in-place! Assumption: text code position is always higher than bytecode pc \n  bytecode Format\n  \n  [CC|6]\n  [CC|6][8]\n  [CC|6][8][8][8]\n  \n  CC  \n  --\n  00 Short 14 Bit constant value\n  01 Long 30 Bit constant value\n  10 Short number command\n  11 Long number command\n  \n  Run: while (pos!=-1) pos=compile(code,pos,&pc);\n*/\nstatic ub1 lastop=0,dictcurrent=0;\nstatic ub2 env[ENVDEPTH];\nstatic ub1 envtype[ENVDEPTH];\nstatic ub1 envtop=0;\n// Temporary dictionary LUT for variables\nstatic dict_cell_t lut[LUTSIZE];\n// top of lut\nstatic ub8 luttop=0;\n\nstatic sb4 compileNumber(ub1 *code,sb2 *position) {\n  sb4 v=0; \n  ub1 s=0;\n  if (code[*position]=='-') { s=1; *position+=1; };\n  while (ISNUM(code[*position])) {\n    v*=10;\n    v+=(code[*position]-48);\n    *position+=1; \n  }\n  return s?-v:v;\n}\n\n// Generates position independent code (PIC)\n// All dara and code references are relative\nsb2 compileToken(ub1 *code,sb2 position, ub2 *pc) {\n  ub2 h,i,n,start,addr;\n  sb4 v;\n  ub1 cells=0,is_num,sign,len;\n  \n  char *word;\n\n  /* Compile one sourec code word (token) */\n  while (code[position] && ISSEP(code[position])) position++;\n  DEBUG(\"compile pos=%d pc=%d lastop=%x envtop=%d env=%x\\n\",position,*pc,lastop,envtop,envtop?envtype[envtop-1]:OP_NOP);\n  if (code[position]==0) return -1;\n\n  is_num=(ISNUM(code[position]) && (ISNUM(code[position+1]) || ISSEP(code[position+1]) || code[position+1]=='l')) ||\n         (code[position]=='-'  && ISNUM(code[position+1]) && \n          (ISNUM(code[position+2]) || ISSEP(code[position+2]) || code[position+1]=='l'));\n  if (!is_num) { \n    // var ident\n    // array ident #cells\n    // : ident .. ;\n    // Identifier or command\n\n#ifdef COMMENTS\n    SKIPCOMMENT(code,position);\n#endif\n    \n    // -1. get identifier\n    word=(char *)&code[position];\n    start=position;\n    while(code[position]!=0 && !ISSEP(code[position])) position++;\n    len=position-start;\n    if (len>8) len=8;\n    DEBUG(\"$ %d start=%d pos=%d pc=%d\\n\",len,start,position,*pc);\n        \n    // 0. Check for pending VAR/ARRAY/DEFINE ops\n#ifdef TWOWORDS\n    if (lastop==OP_VAR||lastop==OP_TWOVAR) {\n#else\n    if (lastop==OP_VAR) {\n#endif\n      memcpy(lut[luttop].name,word,len);\n      lut[luttop].name[len]=0;\n      DEBUG(\"LUT + %s\\n\",lut[luttop].name);\n      len=lastop==OP_VAR?1:2;\n      memset(&code[*pc],0,len*2);\n      lut[luttop].addr=*pc; // start of data\n      lut[luttop].size=len*2;\n      // allocate size in-place\n      *pc+=(len*2);\n      lastop=OP_NOP;\n      luttop++;\n    } else if (lastop==OP_ARRAY) {\n      // array <ident> <numcells>\n      // Non-initialized arrays are appended at the end of the code area (later)\n      // => <array> <-size> <addr> ..\n      // Immediately initialized arrays are placed here\n      // array <ident> { <value1> <value2> ... <valuen> }\n      // => <array> <size> <d1> <d2> .. <dsize> ..\n      SKIPSEP(code,position);\n      if (code[position]=='{') {\n        position++;\n        SKIPSEP(code,position);\n        // reserve space for length field\n        *pc+=2;\n        memcpy(lut[luttop].name,word,len);\n        lut[luttop].name[len]=0;\n        // data start, direct address\n        lut[luttop].addr=*pc;  \n        // get values, count length\n        n=0;\n        while (code[position] && code[position]!='}') {\n          v=compileNumber(code,&position);\n          // store value (single word for now)\n          STORESB2(code,*pc,v); *pc+=2;\n          SKIPSEPCOMMENT(code,position);\n          n++;\n        }\n        if (code[position]!='}') {\n          vmerror=ESYNTAX;\n          return position;\n        }\n        position++;\n        lut[luttop].size=n*2;  // nothing to be allocated at the end, direct address!\n        lut[luttop].flags|=ARRAY;\n        lastop=OP_NOP;\n        // Size of array in word cell units\n        STORESB2(code,lut[luttop].addr-2,n);\n        luttop++;\n      } else if (ISNUM(code[position])) {\n        // reserve space for length field, here negative to indicate no data follows\n        *pc+=2;\n        // but the data address is not known in advance! we nedd indirect addresing\n        memcpy(lut[luttop].name,word,len);\n        lut[luttop].name[len]=0;\n        lut[luttop].addr=*pc; // start of address field (filled later)\n        STORESB2(code,*pc,0);\n        *pc+=2;\n        // get number of cells\n        v=compileNumber(code,&position);\n        // Allocate size cells later at the end of code\n        lut[luttop].size=v*2;  \n        lut[luttop].flags|=(ALLOCATE|ARRAY|INDIRECT);\n        // Store size field (in cell units)\n        STORESB2(code,lut[luttop].addr-2,-v);\n        lastop=OP_NOP;\n        luttop++;\n        // indirect addressing\n        // insert size after (sb2) .. \n      } else {\n        vmerror=ESYNTAX;\n        return position;\n      }\n      lastop=OP_NOP;\n   } else if (lastop==OP_DEFINE) {\n      // insert size after (sb2) ..\n      *pc+=2;\n      // register word in dictionary\n      // TODO: local lut first? only exported words in global dict?\n      // TODO: lock this code; or remove words on this code fragment destruction:\n      // TODO: Maybe clean-up at end?\n      // TODO: Dictionary: linear incremental table (LIFO)?\n      h=dictadd(word,len);\n      dictionary[h].addr=*pc;\n      DEBUG(\"def %d pos=%d pc=%d\\n\",h,position,*pc);\n      // after ; we can update the branch and the LUT\n      // save dirctionary entry\n      dictcurrent=h;\n      lastop=OP_NOP;\n    } else {\n      // 1. Check core word (highest hit probability)\n#ifdef PHLEXER\n      h=corehash(word,len);\n      if (strncmp(word,OPSTRTABLE[h],len)==0) {\n#endif\n#ifdef LSTLEXER\n      h=lookupLST(word,len,CoreLexerTable);\n      if (h!=255) { // found word\n#endif\n        // It is a core word\n        DEBUG(\"OPCODE %x (%x)\\n\",h,h+0x80);\n        code[*pc]=h+0x80; *pc+=1;\n        lastop=h;\n        // Handle control ops, the most complex compiler logic\n        switch (h) {\n          case OP_SCSTR:\n          case OP_CDOTCSTR:\n            // find terminating \"\n            position++;\n            while (code[position]!=0 && code[position]!='\"') {\n              code[*pc]=code[position];\n              *pc+=1;\n              position++;\n            }\n            if (code[position]!='\"') { vmerror=ESYNTAX; return position; };\n            position++;\n            code[*pc-1]=0;\n            break;\n          case OP_DEFRET:\n            // dictcurrent holds last dictionary row index stored by DEFINE; update size field of DEFINE op\n            h=dictcurrent;\n            dictionary[h].size=*pc-dictionary[h].addr-1;\n            *(ub2*)&code[dictionary[h].addr-2]=dictionary[h].size+4; // branch to end of word code (pc+size+4)\n            DEBUG(\"DEFRET %d addr=%d size=%d\\n\",h,dictionary[h].addr,dictionary[h].size);        \n            break;\n          case OP_IF:\n            env[envtop]=*pc;\n            envtype[envtop]=h;\n            envtop++;\n            // reserve branch address \n            *pc+=2;\n            break;\n          case OP_ELSE:\n            if (envtop==0 || envtype[envtop-1]!=OP_IF) { vmerror=ESYNTAXENV; return position; };\n            addr=env[envtop-1];\n            // remember else for control block end (ENDIF)\n            envtype[envtop-1]=h;\n            env[envtop-1]=*pc;\n            // reserve branch address \n            *pc+=2;\n            // update IF branch address\n            *((ub2*)&code[addr])=*pc;  // Code starts after branch address\n            break;\n          case OP_ENDIF:\n            if (envtop==0 || (envtype[envtop-1]!=OP_IF && envtype[envtop-1]!=OP_ELSE)) { vmerror=ESYNTAXENV; return position; };\n            envtop--;\n            *pc-=1;  // virtual op\n            // update IF branch address\n            *((ub2*)&code[env[envtop]])=*pc;\n            break;\n          case OP_DO:\n            // DS: b a -- => FS: -- b a\n            // save loop end address immed. for leave\n            *pc+=2;\n            env[envtop]=*pc;\n            envtype[envtop]=h;\n            envtop++;\n            break;\n          case OP_LOOP:\n          case OP_CPLULOOP:\n            if (envtop==0 || envtype[envtop-1]!=OP_DO) { vmerror=ESYNTAXENV; return position; };\n            envtop--;\n            // FS b a --\n            // increements a; branches to DO if a<b\n            // set LOOP branch address to DO immed.\n            *((ub2*)&code[*pc])=env[envtop];\n            *pc+=2;\n            // update DO branch to end address, too\n            *((ub2*)&code[env[envtop]-2])=*pc;\n            break;\n          case OP_BEGIN:\n            // save loop end address immed. for leaves\n            *pc+=2;\n            env[envtop]=*pc;\n            envtype[envtop]=h;\n            envtop++;\n            break;\n          case OP_AGAIN:\n          case OP_UNTIL:\n            if (envtop==0 || envtype[envtop-1]!=OP_BEGIN) { \n              vmerror=ESYNTAXENV; return position; \n            };\n            // unconditional loop\n            // set AGAIN branch address to BEGIN immed.\n            *((ub2*)&code[*pc])=env[envtop-1];\n            *pc+=2;\n            // update BEGIN branch to end address, too\n            *((ub2*)&code[env[envtop-1]-2])=*pc;\n            break;\n          case OP_LEAVE:\n            // find next OP_BEGIN/OP_DO\n            i=envtop;\n            while (i && envtype[i-1]!=OP_BEGIN && envtype[i-1]!=OP_DO) i--;\n            if (i==0) { vmerror=ESYNTAXENV; return position; };\n            // indirect branching, loop end address is later saved here\n            *((ub2*)&code[*pc])=env[i-1]-2;\n            // reserve branch address            \n            *pc+=2;\n            break;\n        }\n        return position;\n      }\n      // 2. Check global dictionary\n      h=dictlookup(word,len);\n      if (h!=NOTFOUND) {\n        DEBUG(\"CALL %d addr=%d\\n\",h,dictionary[h].addr);\n        // add call op first (prefix op)\n        code[*pc]=OP_CALL+0x80;\n        // TODO Relative branch\n        // *(sb2*)(&code[*pc+1])=dictionary[h].addr-*pc; \n        *(ub2*)(&code[*pc+1])=dictionary[h].addr;\n        *pc+=3;  \n        return position;\n      }\n      // 3. Check local LUT (data/word?)\n      //    LUt is linear table\n      DEBUG(\"LUT top %d\\n\",luttop);\n      for(h=0;h<luttop;h++) {\n        DEBUG(\"LUT lookup %d %s [%d]\\n\",h,lut[h].name,len);\n        if (strncmp(lut[h].name,word,len)==0) {\n          DEBUG(\"var %d addr=%d\\n\",h,lut[h].addr);\n          // TODO: LIT is limited to value +8191!\n          // it is a variable, push CS address literal\n          if (lut[h].flags & INDIRECT) {\n            // needs indirect address resolution op\n            code[*pc]=OP_INDIRECT+0x80; *pc+=1;\n            STORESB2(code,*pc,lut[h].addr);\n          } else {\n            // address value literal\n            *(ub2*)(&code[*pc])=BIGENDUB2(lut[h].addr);\n          }\n          *pc+=2;\n          return position;\n        }\n      }\n      // 4. Check IOS\n      //    LUT is either linear table or phash\n      DEBUG(\"IOS top %d\\n\",iostop);\n      for(h=0;h<iostop;h++) {\n        if (strncmp(ios[h].name,word,len)==0 && ios[h].name[len]==0) {\n          DEBUG(\"ios %d %c %s\\n\",h,ios[h].name,ios[h].type);\n          if (ios[h].type=='F') {\n            // fcall\n            code[*pc]=OP_FCALL+0x80;*pc+=1;\n            // -index\n            code[*pc]=(ub1)-(h+1);*pc+=1;\n          } else if (ios[h].type=='D') {\n            // push index (negative value to distiguish from absolute CS addresses)\n            STORELIT(code,*pc,-(h+1));\n            *pc+=2;\n          }\n          return position;\n        }\n      }\n      vmerror=ENOTFOUND;\n      return position;            \n    }\n  } else {\n    // number\n    // v=0;\n    lastop=OP_NOP;\n    v=compileNumber(code,&position);\n    if (code[position]=='l')  {\n      position++;\n      cells=2;\n    } else cells=1;\n    if (!ISSEP(code[position])) { vmerror=ESYNTAXNUM; return position; };\n    position++; // one digit numbers can overwrite following separator; skip \n    DEBUG(\"LIT %d cells=%d pos=%d pc=%d\\n\",v,cells,position,*pc);\n    if (cells==1) {\n      /* single number word */\n      /* MSB LSB byte order!!! */\n      code[*pc+1] = v&0xff;\n      v=v>>8;\n      code[*pc]   = 0x00 + (v&0x3F);\n      *pc+=2;\n    } else {\n      /* double number word */\n      /* MSB .. LSB byte order!!! */\n      code[*pc+3] = v&0xff;\n      v=v>>8;\n      code[*pc+2] = v&0xff;\n      v=v>>8;\n      code[*pc+1] = v&0xff;\n      v=v>>8;\n      code[*pc]   = 0x40 + (v&0x3F);\n      *pc+=4;\n    }\n  }\n  return position;\n}\n\nsb2 compile(ub1 *code, sb2 position, ub2 *pc) {\n  int i,lastpos=0;\n  lastop=OP_NOP;\n  envtop=0;\n  luttop=0;\n  vmerror=EOK;\n  memset(lut,0,LUTSIZE*sizeof(dict_cell_t));\n  while (position != -1) {\n    position=compileToken(code,position,pc);\n    if (vmerror!=EOK) break;\n    if (position!=-1) lastpos=position;\n  }\n  if (vmerror!=EOK) { PRINT(\"Compiler failed: pos=%d pc=%d err=%d\\n\",position,*pc,vmerror); }\n  // Need finally to update data space at the end of this code frame (non-initialized array data)\n  for(i=0;i<luttop;i++) {\n    if (lut[i].flags & ALLOCATE) {\n      lut[i].flags &= ~ALLOCATE;\n      // head: array size in word units\n      STORESB2(code,*pc,lut[i].size/2);\n      *pc+=2;\n      memset(&code[*pc],0,lut[i].size);\n      if (lut[i].flags & ARRAY) {\n        // update (indirect) data address field\n        STORESB2(code,lut[i].addr,*pc);\n      }\n      *pc+=lut[i].size;\n    }\n  }\n  return position;\n}\n","dict.c":"#include \"config.h\"\n#include \"dict.h\"\n\ndict_cell_t dictionary[DICTSIZE];\nub2 dictcollision=0;\n// very naive hashing ;but  better than iteration of table each time\nub2 dicthash(char *name,ub2 length) {\n  ub2 sum=0,i;\n  while (i<length) { sum+=name[i]; i++; };\n  return sum%DICTSIZE;\n}\n\nub2 dicthash_jenkins(char *key, ub2 len, ub2 tablesize)\n{\n  ub4 hash, i;\n  for(hash = i = 0; i < len; ++i)\n  {\n      hash += key[i];\n      hash += (hash << 10);\n      hash ^= (hash >> 6);\n  }\n  hash += (hash << 3);\n  hash ^= (hash >> 11);\n  hash += (hash << 15);\n  return (ub2)(hash % tablesize);    \n}\n\n// Implementation of Murmur hash for 32-bit size_t.\nub2 dicthash_murmur(char* ptr, ub2 len, ub4 seed, ub2 tablesize)\n{\n  ub1 *buf=(ub1 *)ptr;\n  const ub4 m = 0x5bd1e995;\n  ub4 hash = seed ^ len;\n\n  // Mix 4 bytes at a time into the hash.\n  while (len >= 4)\n  {\n    ub4 k = *((ub4 *)buf);\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    buf += 4;\n    len -= 4;\n  }\n\n  // Handle the last few bytes of the input array.\n  switch (len)\n  {\n    case 3:\n      hash ^= ((ub1)buf[2]) << 16;\n    case 2:\n      hash ^= ((ub1)buf[1]) << 8;\n    case 1:\n      hash ^= ((ub1)buf[0]);\n      hash *= m;\n  };\n\n  // Do a few final mixes of the hash.\n  hash ^= hash >> 13;\n  hash *= m;\n  hash ^= hash >> 15;\n  return (ub2)(hash % tablesize);\n}\n \nub2 dictlookup(char *name, ub2 length) {\n  ub2 i,h = dicthash(name,length);\n  if (length>DICTNAMELENGTH) length=DICTNAMELENGTH;\n  if (dictionary[h].name[0]==0 || strncmp(dictionary[h].name,name,length)!=0) {\n    // incremental search\n    i=0;\n    while (i<DICTSIZE) {\n      h=(h+1)%DICTSIZE;i++;\n      if (dictionary[h].name[0]==0 || strncmp(dictionary[h].name,name,length)!=0) continue;\n      return h;\n    }\n    return NOTFOUND;\n  } else return h;\n}\n\nub2 dictadd(char *name, ub2 length) {\n  ub2 i,h = dicthash(name,length);\n  if (length>DICTNAMELENGTH) length=DICTNAMELENGTH;\n  if (dictionary[h].name[0]==0) {\n    // free slot\n    // allocate slot \n    strncpy(dictionary[h].name,name,length);\n    return h;\n  } else {\n    // incremental search for free slot\n    dictcollision++;\n    i=0;\n    while (i<DICTSIZE) {\n      h=(h+1)%DICTSIZE;i++;\n      if (dictionary[h].name[0]!=0) continue;\n      strncpy(dictionary[h].name,name,length);\n      return h;\n    }\n    return NOTFOUND;\n  }\n}\n\nub2 dictrem(char *name, ub2 length) {\n  ub2 i,h = dicthash(name,length);\n  if (length>DICTNAMELENGTH) length=DICTNAMELENGTH;\n  if (dictionary[h].name[0]==0 || strcmp(dictionary[h].name,name)!=0) {\n    // incremental search\n    i=0;\n    while (i<DICTSIZE) {\n      h=(h+1)%DICTSIZE;i++;\n      if (dictionary[h].name[0]==0 || strncmp(dictionary[h].name,name,length)!=0) continue;\n      memset(&dictionary[h],0,sizeof(dict_cell_t));\n      return h;\n    }\n    return NOTFOUND;\n  } else {\n    memset(&dictionary[h],0,sizeof(dict_cell_t));\n    return h;\n  }\n}\n\n","diss.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"compile.h\"\n#include \"dict.h\"\n#include \"stack.h\"\n#include \"vm.h\"\n#include \"vmloop.h\"\n#include \"vmio.h\"\n#include \"vmcode.h\"\n#include \"vmwords.h\"\n\n#include <stdio.h>\n\nvoid disassemble(ub2 start, ub2 end) {\n  sb2 pc=start;\n  sb2 addr;\n  ub2 a;\n  ub4 da;\n  char *str;\n  ub1 *code=CS;\n  ub1 indef=0;\n  while (pc <= end) {\n    ub1 opcode = DECODE(code[pc]);\n    if (pc>indef) indef=0;\n    switch (opcode) {\n      case OP_ARRAY     : addr=*(ub2*)(&code[pc+1]);\n                          if (addr<0) {\n                            printf(\"%s%0.4x : %s (%d)\\n\",indef?\"  \":\"\",pc,\"array\",-addr);\n                            pc=pc+5;\n                          } else {\n                            printf(\"%s%0.4x : %s [%d]\\n\",indef?\"  \":\"\",pc,\"array\",addr);\n                            pc=pc+addr*2+3; \n                          }\n                          break;\n      case OP_CALL      : addr=*(ub2*)(&code[pc+1]); \n                          printf(\"%s%0.4x : %s (%0.4x)\\n\",indef?\"  \":\"\",pc,\"CALL\",addr); \n                          pc+=3; break;\n      case OP_CDOTCSTR  : str=(char *)&code[pc+1];\n                          printf(\"%s%0.4x : %s (\\\"%s\\\")\\n\",indef?\"  \":\"\",pc,\".\\\"\",str);\n                          pc=pc+(strlen(str)+2); break;\n      case OP_CPLULOOP  : addr=*(ub2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s (%0.4x)\\n\",indef?\"  \":\"\",pc,\"loop+\",addr); \n                          pc+=3; break;\n      case OP_DEFINE    : addr=*(sb2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s (#%0.4x) $%0.4x-$%0.4x\\n\",indef?\"  \":\"\",pc,\"FUNC\",addr,pc+3,pc+addr-1);\n                          indef=pc+addr-1;\n                          pc+=3; break;\n      case OP_DO        : addr=*(sb2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s (!%0.4x)\\n\",indef?\"  \":\"\",pc,\"do\",addr,pc+addr);\n                          pc+=3; break;\n      case OP_FCALL     : addr=code[pc+1];\n                          printf(\"%s%0.4x : %s (@%0.2x)\\n\",indef?\"  \":\"\",pc,\"FCALL\",addr); \n                          pc+=2; break;\n      case OP_IF        : addr=*(sb2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s ($%0.4x)\\n\",indef?\"  \":\"\",pc,\"if\",addr,pc+addr);\n                          pc+=3; break;\n      case OP_INDIRECT  : addr=*(ub2*)(&code[pc+1]);addr=*(ub2*)(&code[addr]);\n                          printf(\"%s%0.4x : %s (%0.4x)\\n\",indef?\"  \":\"\",pc,\"INDIRECT\",addr); \n                          pc+=3; break;\n      case OP_LOOP      : addr=*(ub2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s (%0.4x)\\n\",indef?\"  \":\"\",pc,\"loop\",addr); \n                          pc+=3; break;\n      case OP_LIT       : a=(ub2)(EXTENDSIGN(code[pc]&0x3F)<<8|code[pc+1]);\n                          printf(\"%s%0.4x : %s (%0.4x)\\n\",indef?\"  \":\"\",pc,\"LIT\",a); \n                          pc+=2; break;\n      case OP_NOP       : printf(\"%s%0.4x : %s\\n\",indef?\"  \":\"\",\"NOP\"); break;\n      case OP_SCSTR  :    str=(char *)&code[pc+1];\n                          printf(\"%s%0.4x : %s (\\\"%s\\\")\\n\",indef?\"  \":\"\",pc,\"s\\\"\",str);\n                          pc=pc+(strlen(str)+2); break;\n      case OP_TWOLIT    : da=(ub4)(EXTENDSIGN(code[pc]&0x3F)<<24|code[pc+1]<<16|code[pc+2]<<8|code[pc+3]);\n                          printf(\"%s%0.4x : %s (%0.8x)\\n\",indef?\"  \":\"\",pc,\"2LIT\",da); \n                          pc+=4; break;\n      case OP_TWOVAR    : addr=pc+1;\n                          printf(\"%s%0.4x : %s $%0.4x\\n\",indef?\"  \":\"\",pc,\"2var\",addr);\n                          pc+=5; break;\n      case OP_VAR       : addr=pc+1;\n                          printf(\"%s%0.4x : %s $%0.4x\\n\",indef?\"  \":\"\",pc,\"var\",addr);\n                          pc+=3; break;\n      default: {\n        #ifdef WORDSTRINGS\n          const char *opname =  OPSTRTABLE[opcode];\n          printf(\"%s%0.4x : %s\\n\",indef?\"  \":\"\",pc,opname); pc+=1;\n        #else\n          printf(\"%s%0.4x : %0.2x\\n\",indef?\"  \":\"\",pc,opcode); pc+=1;\n        #endif\n      }\n    }\n  }\n}\n","lookupa.c":"/*\n--------------------------------------------------------------------\nlookupa.c, by Bob Jenkins, December 1996.  Same as lookup2.c\nUse this code however you wish.  Public Domain.  No warranty.\nSource is http://burtleburtle.net/bob/c/lookupa.c\n--------------------------------------------------------------------\n*/\n#ifndef STANDARD\n#include \"standard.h\"\n#endif\n#ifndef LOOKUPA\n#include \"lookupa.h\"\n#endif\n\n/*\n--------------------------------------------------------------------\nmix -- mix 3 32-bit values reversibly.\nFor every delta with one or two bit set, and the deltas of all three\n  high bits or all three low bits, whether the original value of a,b,c\n  is almost all zero or is uniformly distributed,\n* If mix() is run forward or backward, at least 32 bits in a,b,c\n  have at least 1/4 probability of changing.\n* If mix() is run forward, every bit of c will change between 1/3 and\n  2/3 of the time.  (Well, 22/100 and 78/100 for some 2-bit deltas.)\nmix() was built out of 36 single-cycle latency instructions in a \n  structure that could supported 2x parallelism, like so:\n      a -= b; \n      a -= c; x = (c>>13);\n      b -= c; a ^= x;\n      b -= a; x = (a<<8);\n      c -= a; b ^= x;\n      c -= b; x = (b>>13);\n      ...\n  Unfortunately, superscalar Pentiums and Sparcs can't take advantage \n  of that parallelism.  They've also turned some of those single-cycle\n  latency instructions into multi-cycle latency instructions.  Still,\n  this is the fastest good hash I could find.  There were about 2^^68\n  to choose from.  I only looked at a billion or so.\n--------------------------------------------------------------------\n*/\n#define mix(a,b,c) \\\n{ \\\n  a -= b; a -= c; a ^= (c>>13); \\\n  b -= c; b -= a; b ^= (a<<8); \\\n  c -= a; c -= b; c ^= (b>>13); \\\n  a -= b; a -= c; a ^= (c>>12);  \\\n  b -= c; b -= a; b ^= (a<<16); \\\n  c -= a; c -= b; c ^= (b>>5); \\\n  a -= b; a -= c; a ^= (c>>3);  \\\n  b -= c; b -= a; b ^= (a<<10); \\\n  c -= a; c -= b; c ^= (b>>15); \\\n}\n\n/*\n--------------------------------------------------------------------\nlookup() -- hash a variable-length key into a 32-bit value\n  k     : the key (the unaligned variable-length array of bytes)\n  len   : the length of the key, counting by bytes\n  level : can be any 4-byte value\nReturns a 32-bit value.  Every bit of the key affects every bit of\nthe return value.  Every 1-bit and 2-bit delta achieves avalanche.\nAbout 6len+35 instructions.\n\nThe best hash table sizes are powers of 2.  There is no need to do\nmod a prime (mod is sooo slow!).  If you need less than 32 bits,\nuse a bitmask.  For example, if you need only 10 bits, do\n  h = (h & hashmask(10));\nIn which case, the hash table should have hashsize(10) elements.\n\nIf you are hashing n strings (ub1 **)k, do it like this:\n  for (i=0, h=0; i<n; ++i) h = lookup( k[i], len[i], h);\n\nBy Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use this\ncode any way you wish, private, educational, or commercial.\n\nSee http://burtleburtle.net/bob/hash/evahash.html\nUse for hash table lookup, or anything where one collision in 2^32 is\nacceptable.  Do NOT use for cryptographic purposes.\n--------------------------------------------------------------------\n*/\n\nub4 lookup( k, length, level)\nregister ub1 *k;        /* the key */\nregister ub4  length;   /* the length of the key */\nregister ub4  level;    /* the previous hash, or an arbitrary value */\n{\n   register ub4 a,b,c,len;\n\n   /* Set up the internal state */\n   len = length;\n   a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */\n   c = level;           /* the previous hash value */\n\n   /*---------------------------------------- handle most of the key */\n   while (len >= 12)\n   {\n      a += (k[0] +((ub4)k[1]<<8) +((ub4)k[2]<<16) +((ub4)k[3]<<24));\n      b += (k[4] +((ub4)k[5]<<8) +((ub4)k[6]<<16) +((ub4)k[7]<<24));\n      c += (k[8] +((ub4)k[9]<<8) +((ub4)k[10]<<16)+((ub4)k[11]<<24));\n      mix(a,b,c);\n      k += 12; len -= 12;\n   }\n\n   /*------------------------------------- handle the last 11 bytes */\n   c += length;\n   switch(len)              /* all the case statements fall through */\n   {\n     case 11: c+=((ub4)k[10]<<24);\n     case 10: c+=((ub4)k[9]<<16);\n     case 9 : c+=((ub4)k[8]<<8);\n        /* the first byte of c is reserved for the length */\n     case 8 : b+=((ub4)k[7]<<24);\n     case 7 : b+=((ub4)k[6]<<16);\n     case 6 : b+=((ub4)k[5]<<8);\n     case 5 : b+=k[4];\n     case 4 : a+=((ub4)k[3]<<24);\n     case 3 : a+=((ub4)k[2]<<16);\n     case 2 : a+=((ub4)k[1]<<8);\n     case 1 : a+=k[0];\n     /* case 0: nothing left to add */\n   }\n   mix(a,b,c);\n   /*-------------------------------------------- report the result */\n   return c;\n}\n\n\n/*\n--------------------------------------------------------------------\nmixc -- mixc 8 4-bit values as quickly and thoroughly as possible.\nRepeating mix() three times achieves avalanche.\nRepeating mix() four times eliminates all funnels and all\n  characteristics stronger than 2^{-11}.\n--------------------------------------------------------------------\n*/\n#define mixc(a,b,c,d,e,f,g,h) \\\n{ \\\n   a^=b<<11; d+=a; b+=c; \\\n   b^=c>>2;  e+=b; c+=d; \\\n   c^=d<<8;  f+=c; d+=e; \\\n   d^=e>>16; g+=d; e+=f; \\\n   e^=f<<10; h+=e; f+=g; \\\n   f^=g>>4;  a+=f; g+=h; \\\n   g^=h<<8;  b+=g; h+=a; \\\n   h^=a>>9;  c+=h; a+=b; \\\n}\n\n/*\n--------------------------------------------------------------------\nchecksum() -- hash a variable-length key into a 256-bit value\n  k     : the key (the unaligned variable-length array of bytes)\n  len   : the length of the key, counting by bytes\n  state : an array of CHECKSTATE 4-byte values (256 bits)\nThe state is the checksum.  Every bit of the key affects every bit of\nthe state.  There are no funnels.  About 112+6.875len instructions.\n\nIf you are hashing n strings (ub1 **)k, do it like this:\n  for (i=0; i<8; ++i) state[i] = 0x9e3779b9;\n  for (i=0, h=0; i<n; ++i) checksum( k[i], len[i], state);\n\nSee http://burtleburtle.net/bob/hash/evahash.html\nUse to detect changes between revisions of documents, assuming nobody\nis trying to cause collisions.  Do NOT use for cryptography.\n--------------------------------------------------------------------\n*/\nvoid  checksum( k, len, state)\nregister ub1 *k;\nregister ub4  len;\nregister ub4 *state;\n{\n   register ub4 a,b,c,d,e,f,g,h,length;\n\n   /* Use the length and level; add in the golden ratio. */\n   length = len;\n   a=state[0]; b=state[1]; c=state[2]; d=state[3];\n   e=state[4]; f=state[5]; g=state[6]; h=state[7];\n\n   /*---------------------------------------- handle most of the key */\n   while (len >= 32)\n   {\n      a += (k[0] +(k[1]<<8) +(k[2]<<16) +(k[3]<<24));\n      b += (k[4] +(k[5]<<8) +(k[6]<<16) +(k[7]<<24));\n      c += (k[8] +(k[9]<<8) +(k[10]<<16)+(k[11]<<24));\n      d += (k[12]+(k[13]<<8)+(k[14]<<16)+(k[15]<<24));\n      e += (k[16]+(k[17]<<8)+(k[18]<<16)+(k[19]<<24));\n      f += (k[20]+(k[21]<<8)+(k[22]<<16)+(k[23]<<24));\n      g += (k[24]+(k[25]<<8)+(k[26]<<16)+(k[27]<<24));\n      h += (k[28]+(k[29]<<8)+(k[30]<<16)+(k[31]<<24));\n      mixc(a,b,c,d,e,f,g,h);\n      mixc(a,b,c,d,e,f,g,h);\n      mixc(a,b,c,d,e,f,g,h);\n      mixc(a,b,c,d,e,f,g,h);\n      k += 32; len -= 32;\n   }\n\n   /*------------------------------------- handle the last 31 bytes */\n   h += length;\n   switch(len)\n   {\n     case 31: h+=(k[30]<<24);\n     case 30: h+=(k[29]<<16);\n     case 29: h+=(k[28]<<8);\n     case 28: g+=(k[27]<<24);\n     case 27: g+=(k[26]<<16);\n     case 26: g+=(k[25]<<8);\n     case 25: g+=k[24];\n     case 24: f+=(k[23]<<24);\n     case 23: f+=(k[22]<<16);\n     case 22: f+=(k[21]<<8);\n     case 21: f+=k[20];\n     case 20: e+=(k[19]<<24);\n     case 19: e+=(k[18]<<16);\n     case 18: e+=(k[17]<<8);\n     case 17: e+=k[16];\n     case 16: d+=(k[15]<<24);\n     case 15: d+=(k[14]<<16);\n     case 14: d+=(k[13]<<8);\n     case 13: d+=k[12];\n     case 12: c+=(k[11]<<24);\n     case 11: c+=(k[10]<<16);\n     case 10: c+=(k[9]<<8);\n     case 9 : c+=k[8];\n     case 8 : b+=(k[7]<<24);\n     case 7 : b+=(k[6]<<16);\n     case 6 : b+=(k[5]<<8);\n     case 5 : b+=k[4];\n     case 4 : a+=(k[3]<<24);\n     case 3 : a+=(k[2]<<16);\n     case 2 : a+=(k[1]<<8);\n     case 1 : a+=k[0];\n   }\n   mixc(a,b,c,d,e,f,g,h);\n   mixc(a,b,c,d,e,f,g,h);\n   mixc(a,b,c,d,e,f,g,h);\n   mixc(a,b,c,d,e,f,g,h);\n\n   /*-------------------------------------------- report the result */\n   state[0]=a; state[1]=b; state[2]=c; state[3]=d;\n   state[4]=e; state[5]=f; state[6]=g; state[7]=h;\n}\n","lookupl.c":"#include \"config.h\"\n#include \"standard.h\"\n\nub1 lookupLST (char *word, ub2 len, ub1 *table) {\n  ub2 pos = table[(len-1)*2],\n      index = 0;\n  while (index!=len) {\n    // print(index,pos,table[pos],table[pos+1]);\n    if (table[pos]==word[index]) {\n      index++;\n      if (index<len)\n        pos=pos+table[pos+1];   // next node slice start position\n      else return table[pos+1]; // end node, word index\n    } else {\n      pos+=2;\n      if (table[pos]==255) return 255;  // not found\n    }\n  }\n  return 255; // not found\n}\n\n","stack.c":"\n#include \"config.h\"\n#include \"standard.h\"\n#include \"vm.h\"\n#include \"stack.h\"\n\n#ifdef MULTITHREADED\n// Data Stack\nsb2 DS[STACKSIZE*MAXTHREADS];\n// Return Stack\nsb2 RS[RSTACKSIZE*MAXTHREADS];\n// Loop stack\nsb2 FS[FSTACKSIZE*MAXTHREADS];\n#else\n// Data Stack\nsb2 DS[STACKSIZE];\n// Return Stack\nsb2 RS[RSTACKSIZE];\n// Loop stack\nsb2 FS[FSTACKSIZE];\n#endif\nub2 dstop=0,rstop=0,fstop=0;\n\n","vm.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"stack.h\"\n#include \"vm.h\"\n#include \"vmio.h\"\n#include \"vmloop.h\"\n\n#ifdef PROFILING\nunsigned int profileops=0;\n#endif\n\n// Default: frame-less incremental mode (current actice code always on the top)\nub1     CS[CODESIZE];\nub2     cstop=0;\n\n#ifdef MULTITASKING\nub2     frtop=0;\n#endif\n\nsb2     pctop=0;\nub1     vmerror=EOK;\nub1     vmstate=VMIDLE;  // vm state\nub1     vmbase=0;\n// ub4     vmsteps=0;\n\n#ifdef MULTITASKING\n  frame_t   frames[FRAMES];\n  // task states for one VM\n  vmtask_t  vmtasks[MAXTASKS];\n  ub4       vmtaskmask=0;\n  ub1       vmthreadcurrent;\n#else\n  vmevent_t vmevent;\n#endif\n\nvoid    *fcalls[8];\nvoid    *io[8];\n\n\nvoid vmraiseerror(ub1 error) {\n  vmerror=error;\n};\n\nvoid vmreset() {\n  #ifdef PROFILING\n    profileops=0;\n  #endif\n  #ifdef MULTITASKING\n    vmthreadmask=0;\n    memset((void *)&vmtasks,0,sizeof(vmtask_t)*MAXTASKS);\n  #else\n    vmevent.timeout=0;\n    vmevent.v=NULL;\n  #endif\n  \n  dstop=0;\n  rstop=0;\n  fstop=0;\n}\n\n// Main vmloop execution handler\n// Return 0: normal exit, <0: error code, >0: timeout in milli seconds\nsb2 vmrun (ub2 steps) {\n  ub4 now=vmMilli();\n#ifdef MULTITHREADED\n  // modify pctop, and all stack pointers, too!\n#else\n  if (vmevent.timeout && now >= vmevent.timeout) {\n    pctop=-pctop;\n    vmevent.timeout=0;\n  }\n  if (vmevent.v && *vmevent.v == vmevent.c) {\n    pctop=-pctop;\n    vmevent.v=NULL;\n  }\n  if (pctop>=0) pctop = vmloop(CS,pctop,steps);\n  if (pctop<0) { \n    /* suspended */\n    now=vmMilli();\n    if (vmevent.timeout) return vmevent.timeout-now;\n  }\n  return vmerror?-vmerror:0;\n#endif  \n}\n\n","vmio.c":"\n#include \"standard.h\"\n#include \"config.h\"\n#include \"vmio.h\"\n\n// linear table; can be replaced with phash\nub1 iostop=0;\nios_t ios[IOSIZE];\n\nvoid iosInit() {\n  memset((void *)&ios[0],0,sizeof(ios_t)*IOSIZE);\n  iostop=0;\n}\n// (name,FIOSCALLBACK(function),01234,0124,0124)\nub1 fiosAdd(char *name, void (*callback)(), ub1 args, ub1 argsize, ub1 retsize) {\n  ios_t *io=&ios[iostop];\n  ub1 length=strlen(name);\n  if (length>DICTNAMELENGTH) length=DICTNAMELENGTH;\n  strncpy(io->name,name,DICTNAMELENGTH);\n  io->type='F';\n  io->callback=(void *)callback;\n  io->args=args;\n  io->argsize=argsize;\n  io->retsize=retsize;\n  iostop++;\n  return iostop-1;\n}\n\n\n\n// (name,IOSDATA(data),01..,124)\nub1 diosAdd(char *name, void *data, ub2 cells, ub1 size) {\n  ios_t *io=&ios[iostop];\n  ub1 length=strlen(name);\n  if (length>DICTNAMELENGTH) length=DICTNAMELENGTH;\n  strncpy(io->name,name,DICTNAMELENGTH);\n  io->type='D';\n  io->data=(void *)data;\n  io->cells=cells;\n  io->size=size;\n  iostop++;\n  return iostop-1;\n}\n\n// System millisecond clock returning current (ub4) millisecods\nMILLI;\n\n"},"words":["dup","2dup","drop","2drop","swap","2swap","over","2over","rot","2rot","-dup","pick",">f","f>","f","fdrop","fpick","+","2+","-","2-","*","2*","/","2/","mod","2mod","max","2max","min","2min","abs","2abs","minus","2minus","and","2and","or","2or","xor","2xor","=","2=","<","2<",">","2>","0<","0=",".",".\"",".s","2.","cr","@","2@","s@","s\"","!","2!","s!","2ext","2red","$","cell+","array",":",";","return","do","loop","+loop","leave","i","j","if","else","endif","begin","again","until","while","var","2var","const","forget","send","sendn","receive","read","write","load","save","out","inp","sleep","yield","base","one","await","end"],"ops":{"ABS":"STACKCHECK(1);a=POP();\nPUSH(a<0?-a:a);\npc++;DISPATCH(); /* abs */","AGAIN":"pc=(*(ub2*)(&code[pc+1]));\nDISPATCH(); /* again */","AND":"STACKCHECK(2);a=POP();b=POP();PUSH((sb2)((ub2)a & (ub2)b));\npc++;DISPATCH(); /* and */","ARRAY":"DEBUG(\"ARRAY BRANCH %dn\",(*(sb2*)(&code[pc+1])));\na=*((sb2*)&code[pc+1]); if (a<0) pc=pc+5; else pc=pc+a*2+3;\nDISPATCH(); /* array */\n","AWAIT":"STACKCHECK(2);addr=POP();a=POP();\nif (ios[addr].type!='D') { vmerror=EIO; goto onerror; };\nvmevent.v=&DIOSDATADEREF(ub2,addr);\nvmevent.c=a;\npc++;goto suspend; /* await */","BASE":"STACKCHECK(1);vmbase=POP();\npc++;DISPATCH(); /* base */","BEGIN":"pc+=3;DISPATCH(); /* begin */","BRANCH":"pc=(*(ub2*)(&code[pc+1]));DISPATCH();","BRANCHZ":"a=POP();if (a==0) pc=(*(ub2*)(&code[pc+1])); else pc+=3;DISPATCH();","CALL":"/* TODO rel. branch addr=pc+*(sb2*)(&code[pc+1])*/\naddr=*(ub2*)(&code[pc+1]);\nDEBUG(\"CALL %dn\",a);\\\nRPUSH(pc+3);\npc=addr;DISPATCH(); /* call */","CDOLL":"if ((code[pc+1]&OP_CALL)==OP_CALL) { a=*(sb2*)(&code[pc+2]); pc+=4;}\nelse { a=*(sb1*)(&code[pc+2]); pc+=3; };\nPUSH(a); DISPATCH(); /* $ */","CDOT":"STACKCHECK(1); CONSOLEFMT(vmbase==0?\"%d \":\"%x \",vmbase==0?(sb2)POP():(ub2)POP()); pc++;\nDISPATCH(); /* . */","CDOTCSTR":"char *str=(char *)&code[pc+1];CONSOLE(str);\npc+=(strlen(str)+2);DISPATCH(); /* .\" */","CDOTS":"STACKCHECK(1);a=POP();b=a/2+a%2;\nSTACKCHECK(b);for(c=1;c<=b;c++) { ub2 cc=(ub2)POP(); CONSOLEFMT(\"%c\",(cc>>8)&0xFF); CONSOLEFMT(\"%c\",cc&0xFF);}\nif (a%2==0) CONSOLEFMT(\"%c\",' ');\npc++;DISPATCH(); /* .s */","CELLCPLU":"STACKCHECK(2);a=POP();addr=POP();PUSH(addr+a*2);\npc++;DISPATCH(); /* cell+ */","CEQ":"STACKCHECK(2);a=POP();b=POP();PUSH(a==b?1:0);\npc++;DISPATCH(); /* = */","CGT":"STACKCHECK(2);a=POP();b=POP();PUSH(b>a?1:0);\npc++;DISPATCH(); /* > */","CGTF":"STACKCHECK(1);a=POP();FPUSH(a);\npc++;DISPATCH(); /* >f */","CLT":"STACKCHECK(2);a=POP();b=POP();PUSH(b<a?1:0);\npc++;DISPATCH(); /* < */","CMIN":"STACKCHECK(2);a=POP();b=POP();PUSH(b-a);\npc++;DISPATCH(); /* - */","CMINDUP":"STACKCHECK(1);if (STACKTOP(1)!=0) { a=STACKTOP(1);PUSH(a); };\npc++;DISPATCH(); /* -dup */","CMUL":"STACKCHECK(2);a=POP();b=POP();PUSH(a*b);\npc++;DISPATCH(); /* * */","CONST":"pc++;DISPATCH(); /* const */","CPLU":"STACKCHECK(2);a=POP();b=POP();PUSH(a+b);\npc++;DISPATCH(); /* + */","CPLULOOP":"STACKCHECK(1);FSTACKCHECK(2);FSTACKTOP(1)+=(POP());\nif (FSTACKTOP(1)<FSTACKTOP(2)) pc=(*(ub2*)(&code[pc+1])); else { FPOP2(); pc+=3; };\nDISPATCH(); /* +loop */","CQUO":"STACKCHECK(2);a=POP();b=POP();PUSH(b/a);\npc++;DISPATCH(); /* / */","CR":"CONSOLENL();\npc++;DISPATCH(); /* cr */","DEFINE":"DEBUG(\"DEFINE BRANCH %dn\",(*(sb2*)(&code[pc+1])));\npc=pc+(*(sb2*)(&code[pc+1]));DISPATCH(); /* : */\n","DEFRET":"DEBUG(\"RETURNn\");\nRSTACKCHECK(1);pc=RPOP();\nDISPATCH(); /* return */\n","DO":"STACKCHECK(2);FPUSH2U(POP2U());\npc+=3;DISPATCH(); /* do */","DROP":"STACKCHECK(1);POP();\npc++;DISPATCH(); /* drop */","DUP":"STACKCHECK(1);a=STACKTOP(1);\nPUSH(a);\npc++;DISPATCH(); /* dup */","ELSE":"pc=(*(ub2*)(&code[pc+1]));\nDISPATCH(); /* else */","END":"goto end; /* end */","ENDIF":"pc++;DISPATCH(); /* endif */","F":"FSTACKCHECK(1);a=FPOP();PUSH(a)\npc++;DISPATCH(); /* f */","FCALL":"pc++;addr=(-(sb1)code[pc])-1;\nif (addr>IOSIZE || ios[addr].type!='F') { vmerror=EFCALL; goto onerror; };\nif (ios[addr].argsize==2) switch (ios[addr].args) {\ncase 1: STACKCHECK(1); a=POP(); break;\ncase 2: STACKCHECK(2); b=POP(); a=POP(); break;\ncase 3: STACKCHECK(3); c=POP(); b=POP(); a=POP(); break;\ncase 4: STACKCHECK(4); d=POP(); c=POP(); b=POP(); a=POP(); break;\n}\nif (ios[addr].argsize==4) switch (ios[addr].args) {\ncase 1: STACKCHECK(2); da=POP2(); break;\ncase 2: STACKCHECK(4); db=POP2(); da=POP2(); break;\ncase 3: STACKCHECK(6); dc=POP2(); db=POP2(); da=POP2(); break;\ncase 4: STACKCHECK(8); dd=POP2(); dc=POP2(); db=POP2(); da=POP2(); break;\n}\nif (ios[addr].retsize==0 && ios[addr].argsize<4) switch (ios[addr].args) {\ncase 0: FIOSCALL0(addr); break;\ncase 1: FIOSCALL0(addr,a); break;\ncase 2: FIOSCALL0(addr,a,b); break;\ncase 3: FIOSCALL0(addr,a,b,c); break;\ncase 4: FIOSCALL0(addr,a,b,c,d); break;\n}\nelse if (ios[addr].retsize==0 && ios[addr].argsize==4) switch (ios[addr].args) {\ncase 1: FIOSCALL0(addr,da); break;\ncase 2: FIOSCALL0(addr,da,db); break;\ncase 3: FIOSCALL0(addr,da,db,dc); break;\ncase 4: FIOSCALL0(addr,da,db,dc,dd); break;\n}\nelse if (ios[addr].retsize==2 && (ios[addr].argsize==2||ios[addr].args==0)) switch (ios[addr].args) {\ncase 0: PUSH(FIOSCALL2(addr)); break;\ncase 1: PUSH(FIOSCALL2(addr,a)); break;\ncase 2: PUSH(FIOSCALL2(addr,a,b)); break;\ncase 3: PUSH(FIOSCALL2(addr,a,b,c)); break;\ncase 4: PUSH(FIOSCALL2(addr,a,b,c,d)); break;\n}\nelse if (ios[addr].retsize==4 && (ios[addr].argsize==2||ios[addr].args==0)) switch (ios[addr].args) {\ncase 0: PUSH2(FIOSCALL4(addr)); break;\ncase 1: PUSH2(FIOSCALL4(addr,a)); break;\ncase 2: PUSH2(FIOSCALL4(addr,a,b)); break;\ncase 3: PUSH2(FIOSCALL4(addr,a,b,c)); break;\ncase 4: PUSH2(FIOSCALL4(addr,a,b,c,d)); break;\n}\nelse if (ios[addr].retsize==0 && (ios[addr].argsize==4||ios[addr].args==0)) switch (ios[addr].args) {\ncase 0: FIOSCALL0(addr); break;\ncase 1: FIOSCALL0(addr,da); break;\ncase 2: FIOSCALL0(addr,da,db); break;\ncase 3: FIOSCALL0(addr,da,db,dc); break;\ncase 4: FIOSCALL0(addr,da,db,dc,dd); break;\n}\nelse if (ios[addr].retsize==2 && (ios[addr].argsize==4||ios[addr].args==0)) switch (ios[addr].args) {\ncase 0: PUSH(FIOSCALL2(addr)); break;\ncase 1: PUSH(FIOSCALL2(addr,da)); break;\ncase 2: PUSH(FIOSCALL2(addr,da,db)); break;\ncase 3: PUSH(FIOSCALL2(addr,da,db,dc)); break;\ncase 4: PUSH(FIOSCALL2(addr,da,db,dc,dd)); break;\n}\nelse if (ios[addr].retsize==4 && (ios[addr].argsize==4||ios[addr].args==0)) switch (ios[addr].args) {\ncase 0: PUSH2(FIOSCALL4(addr)); break;\ncase 1: PUSH2(FIOSCALL4(addr,da)); break;\ncase 2: PUSH2(FIOSCALL4(addr,da,db)); break;\ncase 3: PUSH2(FIOSCALL4(addr,da,db,dc)); break;\ncase 4: PUSH2(FIOSCALL4(addr,da,db,dc,dd)); break;\n}\nif (vmerror) goto onerror; pc++;DISPATCH(); /* fcall */","FCGT":"FSTACKCHECK(1);a=FPOP();PUSH(a);\npc++;DISPATCH(); /* f> */","FDROP":"STACKCHECK(1);a=POP();FSTACKCHECK(a);fstop-=a;\npc++;DISPATCH(); /* f */","FETCH":"STACKCHECK(1);addr=(ub2)POP();\nPUSH(*((sb2*)&code[addr]));\npc++;DISPATCH(); /* @ */","FORGET":"vmerror=ENOTIMPLEMENTED; goto onerror;\n /* forget */","FPICK":"STACKCHECK(1);b=POP();FSTACKCHECK(b);a=FSTACKTOP(b);PUSH(a)\npc++;DISPATCH(); /* f */","I":"FSTACKCHECK(2);PUSH(FSTACKTOP(1));\npc++;DISPATCH(); /* i */","IF":"STACKCHECK(1); a=POP(); if (a==0) pc=(*(ub2*)(&code[pc+1])); else pc+=3;\nDISPATCH(); /* if */","INDIRECT":"addr=*(ub2*)(&code[pc+1]);addr=*(ub2*)(&code[addr]);PUSH(addr);\npc=pc+3;DISPATCH();","INP":"pc++;DISPATCH(); /* inp */","J":"FSTACKCHECK(4);PUSH(FSTACKTOP(3));\npc++;DISPATCH(); /* j */","LEAVE":"addr=*(ub2*)(&code[pc+1]);\nDEBUG(\"LEAVE %x %xn\",addr,*(ub2*)(&code[addr]));\nif (DECODE(code[addr-1])==OP_DO) FPOP2();\naddr=*(ub2*)(&code[addr]);\npc=addr;\nDISPATCH(); /* leave */\n","LIT":"DEBUG(\"LIT %xn\",EXTENDSIGN(code[pc]&0x3F)<<8|code[pc+1]);\\\nPUSH((ub2)(EXTENDSIGN(code[pc]&0x3F)<<8|code[pc+1])); pc+=2;\nDISPATCH();","LOAD":"vmerror=ENOTIMPLEMENTED; goto onerror;\n /* load */","LOOP":"FSTACKCHECK(2);FSTACKTOP(1)+=1;\nif (FSTACKTOP(1)<FSTACKTOP(2)) pc=(*(ub2*)(&code[pc+1])); else { FPOP2(); pc+=3; }\nDISPATCH(); /* loop */","MAX":"STACKCHECK(2);a=POP();b=POP();PUSH(b>a?b:a);\npc++;DISPATCH(); /* max */","MIN":"STACKCHECK(2);a=POP();b=POP();PUSH(b<a?b:a);\npc++;DISPATCH(); /* min */","MINUS":"STACKCHECK(1);a=POP();\nPUSH(-a);\npc++;DISPATCH(); /* minus */","MOD":"STACKCHECK(1);a=POP();b=POP();PUSH(b%a);\npc++;DISPATCH(); /* mod */","NOP":"pc++;DISPATCH();","ONE":"PUSH(1);\npc++;DISPATCH(); /* one */","OR":"STACKCHECK(2);a=POP();b=POP();PUSH((sb2)((ub2)a | (ub2)b));\npc++;DISPATCH(); /* or */","OUT":"STACKCHECK(1); OUT(POP());\npc++;DISPATCH(); /* out */","OVER":"STACKCHECK(2);a=STACKTOP(2);PUSH(a);\npc++;DISPATCH(); /* over */","PICK":"STACKCHECK(1);b=POP();STACKCHECK(b);a=STACKTOP(b);PUSH(a)\npc++;DISPATCH(); /* f */","READ":"STACKCHECK(1);addr=(ub2)(-POP()-1);\nif (addr>=IOSIZE || ios[addr].type!='D') { vmerror=EIO; goto onerror; };\nif (ios[addr].cells) { STACKCHECK(1); a=POP();\nif (a<0 || a>=ios[addr].cells) { vmerror=EINDEX; goto onerror; };\nswitch (ios[addr].size) {\ncase 1: PUSH(DIOSARRAYINDEX(ub1,addr,a));   break;\ncase 2: PUSH(DIOSARRAYINDEX(sb2,addr,a));   break;\ncase 4: PUSH2(DIOSARRAYINDEX(sb4,addr,a));  break;\n}\n} else {\nswitch (ios[addr].size) {\ncase 1: PUSH(DIOSDATADEREF(ub1,addr));   break;\ncase 2: PUSH(DIOSDATADEREF(sb2,addr));   break;\ncase 4: PUSH2(DIOSDATADEREF(sb4,addr));  break;\n}\n}\npc++;DISPATCH(); /* read */","RECEIVE":"vmerror=ENOTIMPLEMENTED; goto onerror;\n /* receive */","RETURN":"DEBUG(\"RETURNn\");\\\nRSTACKCHECK(1);pc=RPOP();\nDISPATCH(); /* ; */","ROT":"STACKCHECK(3);a=POP();b=POP();c=POP();\nPUSH(b);PUSH(a);PUSH(c);\npc++;DISPATCH(); /* rot */","SAVE":"vmerror=ENOTIMPLEMENTED; goto onerror;\n /* save */","SCSTR":"ub1 *str=(char *)&code[pc+1];a=strlen(str);b=a/2+a%2;\nfor(c=b-1;c>=0;c--) PUSH((str[c*2]<<8)+str[c*2+1]); PUSH(a);\npc+=(a+2);DISPATCH(); /* s\" */\n","SEND":"STACKCHECK(2); a=POP(); b=POP();SEND(a,b);\npc++;DISPATCH(); /* send */","SENDN":"STACKCHECK(3); addr=POP(); a=POP(); b=POP(); SENDN(addr,a,b);\npc++;DISPATCH(); /* send */","SFETCH":"STACKCHECK(1);addr=(ub2)POP();a=*((sb2*)&code[addr]);b=a/2+a%2;\nfor(c=b;c>0;c--) PUSH(((sb2*)&code[addr])[c]); PUSH(a);\npc++;DISPATCH(); /* s@ */\n","SLEEP":"STACKCHECK(1); a=POP(); vmevent.timeout=vmMilli()+a;\npc++;goto suspend; /* sleep */","SSTORE":"STACKCHECK(2);addr=(ub2)POP();a=POP();b=a/2+a%2;\nSTACKCHECK(b);*((sb2*)&code[addr])=a;\nfor(c=1;c<=b;c++) ((ub2*)&code[addr])[c]=(ub2)POP();\npc++;DISPATCH(); /* s! */","STORE":"STACKCHECK(2);addr=(ub2)POP();a=POP();\n*((sb2*)&code[addr])=a;\npc++;DISPATCH(); /* ! */","SWAP":"STACKCHECK(2);a=POP();b=POP();\nPUSH(a);PUSH(b);\npc++;DISPATCH(); /* swap */","TWOABS":"STACKCHECK(2);da=POP2();\nPUSH2(da<0?-da:da);\npc++;DISPATCH(); /* 2abs */","TWOAND":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da&db);\npc++;DISPATCH(); /* 2and */","TWOCDOT":"STACKCHECK(2);CONSOLEFMT(vmbase==0?\"%d \":\"%x \",vmbase==0?(sb4)POP2():(ub4)POP2());\npc++;DISPATCH(); /* 2. */","TWOCEQ":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH(da==db?1:0);\npc++;DISPATCH(); /* 2= */","TWOCGT":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH(db>da?1:0);\npc++;DISPATCH(); /* 2> */","TWOCLT":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH(db<da?1:0);\npc++;DISPATCH(); /* 2< */","TWOCMIN":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(db-da);\npc++;DISPATCH(); /* 2- */","TWOCMUL":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da*db);\npc++;DISPATCH(); /* 2* */","TWOCPLU":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da+db);\npc++;DISPATCH(); /* 2+ */","TWOCQUO":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(db/da);\npc++;DISPATCH(); /* 2/ */","TWODROP":"STACKCHECK(2);POP2();\npc++;DISPATCH(); /* 2drop */","TWODUP":"STACKCHECK(2);da=STACKTOP2(1);\nPUSH2(da);\npc++;DISPATCH(); /* 2dup */","TWOEXT":"STACKCHECK(1);a=POP();PUSH2((sb4)a);\npc++;DISPATCH(); /* 2ext */","TWOFETCH":"STACKCHECK(1);addr=(ub2)POP();\nPUSH2(*((sb4*)&code[addr]));\npc++;DISPATCH(); /* 2@ */","TWOLIT":"DEBUG(\"TWOLIT %xn\",EXTENDSIGN(code[pc]&0x3F)<<24|code[pc+1]<<16|code[pc+2]<<8|code[pc+3]);\\\nPUSH2((ub4)(EXTENDSIGN(code[pc]&0x3F)<<24|code[pc+1]<<16|code[pc+2]<<8|code[pc+3])); pc+=4;\nDISPATCH();","TWOMAX":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(db>da?db:da);\npc++;DISPATCH(); /* 2max */","TWOMIN":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(db<da?db:da);\npc++;DISPATCH(); /* 2min */","TWOMINUS":"STACKCHECK(2);da=POP2();\nPUSH2(-da);\npc++;DISPATCH(); /* 2minus */","TWOMOD":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(db%da);\npc++;DISPATCH(); /* 2mod */","TWOOR":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da|db);\npc++;DISPATCH(); /* 2or */","TWOOVER":"vmerror=ENOTIMPLEMENTED; goto onerror;\n /* 2over */","TWORED":"STACKCHECK(2);da=POP2();PUSH((sb2)da);\npc++;DISPATCH(); /* 2red */","TWOROT":"vmerror=ENOTIMPLEMENTED; goto onerror;\n /* 2rot */","TWOSTORE":"STACKCHECK(3);addr=(ub2)POP();da=POP2();\n*((sb4*)&code[addr])=da;\npc++;DISPATCH(); /* 2! */","TWOSWAP":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da);PUSH2(db);pc++;DISPATCH(); /* 2swap */","TWOVAR":"pc+=5;DISPATCH(); /* 2var */","TWOXOR":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da^db);\npc++;DISPATCH(); /* 2xor */","UNTIL":"STACKCHECK(1);a=POP();\nif (a) pc+=3; else pc=(*(ub2*)(&code[pc+1]));\nDISPATCH(); /* until */","VAR":"pc+=3;DISPATCH(); /* var */","WHILE":"STACKCHECK(1);a=POP();\nif (a==0) pc+=3; else pc=(*(ub2*)(&code[pc+1]));\npc++;DISPATCH(); /* while */","WRITE":"STACKCHECK(1);addr=(ub2)(-POP()-1);\nif (addr>=IOSIZE || ios[addr].type!='D') { vmerror=EIO; goto onerror; };\nif (ios[addr].cells) { STACKCHECK(1); a=POP();\nif (a<0 || a>=ios[addr].cells) { vmerror=EINDEX; goto onerror; };\nswitch (ios[addr].size) {\ncase 1: STACKCHECK(1); DIOSARRAYINDEX(ub1,addr,a)=(ub1)POP(); break;\ncase 2: STACKCHECK(1); DIOSARRAYINDEX(sb2,addr,a)=POP();      break;\ncase 4: STACKCHECK(2); DIOSARRAYINDEX(sb4,addr,a)=POP2();     break;\n}\n} else {\nswitch (ios[addr].size) {\ncase 1: STACKCHECK(1); DIOSDATADEREF(ub1,addr)=(ub1)POP();    break;\ncase 2: STACKCHECK(1); DIOSDATADEREF(sb2,addr)=POP();         break;\ncase 4: STACKCHECK(2); DIOSDATADEREF(sb4,addr)=POP2();        break;\n}\n}\npc++;DISPATCH(); /* write */","XOR":"STACKCHECK(2);a=POP();b=POP();PUSH((sb2)((ub2)a ^ (ub2)b));\npc++;DISPATCH(); /* xor */","YIELD":"DEBUG(\"yield\\n\"); pc++; goto end; /* yield */","ZEROCEQ":"STACKCHECK(1);a=POP();PUSH(a==0?1:0);\npc++;DISPATCH(); /* 0= */","ZEROCLT":"STACKCHECK(1);a=POP();PUSH(a<0?1:0);\npc++;DISPATCH(); /* 0< */"}}}