{"C":{"path":"../../src/c","header":{"compile.h":"#ifndef __COMPILE_H\n#define __COMPILE_H\nextern sw1 compileToken(ub1  *code,sw1 position, uw1 *pc);\n\n#if COMPILEINCR==1\nEXTERN sw1 compile(ub1 *code,sw1 position, uw1 *pc, sb2 steps);\n#else\nEXTERN sw1 compile(ub1 *code,sw1 position, uw1 *pc);\n#endif\n// Upper boundary of locked CS range containing words in global dictionary\nextern sw1 vmcslocked;\n#endif\n","dict.h":"#ifndef __DICT_H\n#define __DICT_H\n#include \"standard.h\"\n\n#ifndef DICTNAMELENGTH\n#define DICTNAMELENGTH  8\n#endif\n#define ALLOCATE  0x01\n#define ARRAY     0x02\n#define INDIRECT  0x04\n#define FUNCTION  0x08\n#define NOTFOUND  0xFFFF\n\nstruct dict_cell {\n   char name[DICTNAMELENGTH];\n   uw1  addr;   // CS\n   uw1  size;\n   ub1  flags;\n#if DICTLINEAR!=1\n   sb1  next;\n#endif\n};\n\ntypedef struct dict_cell dict_cell_t;\n// Main word dictionary\nextern dict_cell_t dictionary[];\n#if DICTLINEAR!=1\nextern ub2 dictcollision;\n#endif\n#if DICTLINEAR==1\nextern ub2 dicttop;\n#endif\nextern ub2 dicthash(char *name, ub2 length, ub2 tablesize);\nextern ub2 dictlookup(dict_cell_t *dictionary, ub2 dictsize, char *name, ub2 length);\nextern ub2 dictadd(dict_cell_t *dictionary, ub2 dictsize, char *name, ub2 length);\nextern ub2 dictrem(dict_cell_t *dictionary, ub2 dictsize, char *name, ub2 length);\nextern void dictclean(dict_cell_t *dictionary, ub2 dictsize, ub2 start, ub2 end);\nextern void dictinit(dict_cell_t *dictionary, ub2 dictsize);\n#endif\n\n","diss.h":"#ifndef __DISS_H\n#define __DISS_H\nextern ub2 disassemble(ub2 start, ub2 end);\n#endif\n\n","lookupa.h":"/*\n------------------------------------------------------------------------------\nBy Bob Jenkins, September 1996.\nlookupa.h, a hash function for table lookup, same function as lookup.c.\nUse this code in any way you wish.  Public Domain.  It has no warranty.\nSource is http://burtleburtle.net/bob/c/lookupa.h\n------------------------------------------------------------------------------\n*/\n#ifndef _H_LOOKUPA\n#define _H_LOOKUPA\n\n\n#ifndef STANDARD\n#include \"standard.h\"\n#endif\n\nextern ub1 lookupPH (char *key, ub1 length, sb1* G, ub1 Glength, ub1* V, ub1 Vlength);\n\n#endif /* H_LOOKUPA */\n","lookupl.h":"#ifndef _LOOKUPLST_H\n#define _LOOKUPLST_H\nextern ub1 lookupLST (char *word, ub2 len, ub1 *table);\n#endif\n","stack.h":"#ifndef __STACK_H\n#define __STACK_H\n#include \"standard.h\"\nextern sw1 DS[];  // data stack \nextern sw1 RS[];  // return stack\nextern sw1 FS[];  // loop stack\nextern uw1 dstop; // data stack segment pointer\nextern uw1 rstop; // data stack segment pointer\nextern uw1 fstop; // loop stack segment pointer\n\n// Long number (double word) storage depends on CPU endianess: Little Endian. LSW MSW -- or Bif Endian. MSW LSW --\n#define POP()         DS[(dstop--)-1]\n#define RPOP()        RS[(rstop--)-1]\n#define FPOP()        FS[(fstop--)-1]\n#define PUSH(v)       DS[dstop++]=v;\n#define RPUSH(v)      RS[rstop++]=v;\n#define FPUSH(v)      FS[fstop++]=v;\n#define STACKTOP(n)   DS[dstop-n]\n#define FSTACKTOP(n)  FS[fstop-n]\n#define RSTACKTOP(n)  RS[dstop-n]\n#define STACKCHECK(n)   if (n>dstop) { vmerror=ESTACK; goto onerror; }\n#define FSTACKCHECK(n)  if (n>fstop) { vmerror=ESTACK; goto onerror; }\n#define RSTACKCHECK(n)  if (n>rstop) { vmerror=ERSTACK; goto onerror; }\n#define DEBUGDS() {int i;for(i=0;i<dstop;i++) printf(\" %x \",DS[i]); printf(\"\\n\"); }\n\n#if TWOWORDS==1\n#define POP2()        (*(sw2*)(&DS[dstop-=2]))\n#define POP2U()       (*(uw2*)(&DS[dstop-=2]))\n#define RPOP2()       (*(sw2*)(&RS[rstop-=2]))\n#define FPOP2()       (*(sw2*)(&FS[fstop-=2]))\n#define PUSH2(v)      *(sw2*)(&DS[dstop])=v; dstop+=2;\n#define RPUSH2(v)     *(sw2*)(&RS[rstop])=v; rstop+=2;\n#define FPUSH2(v)     *(sw2*)(&FS[fstop])=v; fstop+=2;\n#define FPUSH2U(v)    *(uw2*)(&FS[fstop])=(ub4)v; fstop+=2;\n#define STACKTOP2(n)  (*(sw2*)(&DS[dstop-n-1]))\n#define FSTACKTOP2(n) (*(sw2*)(&FS[fstop-n-1])) \n#define RSTACKTOP2(n) (*(sw2*)(&RS[rstop-n-1]))\n#endif\n\n#endif\n","standard.h":"/*\n------------------------------------------------------------------------------\nStandard definitions and types, Bob Jenkins\n------------------------------------------------------------------------------\n*/\n#ifndef STANDARD\n# define STANDARD\n# ifndef STDIO\n#  include <stdio.h>\n#  define STDIO\n# endif\n# ifndef STDDEF\n#  include <stddef.h>\n#  define STDDEF\n# endif\n# ifndef STDLUIB\n#   include <stdlib.h>\n#   define STDLIB\n# endif\n# ifndef STDSTRING\n#    include <string.h>\n#    define STDSTRING\n# endif\ntypedef  unsigned long long  ub8;\n#define UB8MAXVAL 0xffffffffffffffffLL\n#define UB8BITS 64\ntypedef    signed long long  sb8;\n#define SB8MAXVAL 0x7fffffffffffffffLL\ntypedef  unsigned long  int  ub4;   /* unsigned 4-byte quantities */\n#define UB4MAXVAL 0xffffffff\ntypedef    signed long  int  sb4;\n#define UB4BITS 32\n#define SB4MAXVAL 0x7fffffff\ntypedef  unsigned short int  ub2;\n#define UB2MAXVAL 0xffff\n#define UB2BITS 16\ntypedef    signed short int  sb2;\n#define SB2MAXVAL 0x7fff\ntypedef  unsigned       char ub1;\n#define UB1MAXVAL 0xff\n#define UB1BITS 8\ntypedef    signed       char sb1;   /* signed 1-byte quantities */\n#define SB1MAXVAL 0x7f\n// typedef                 int  word;  /* fastest type available */\n\n#define bis(target,mask)  ((target) |=  (mask))\n#define bic(target,mask)  ((target) &= ~(mask))\n#define bit(target,mask)  ((target) &   (mask))\n#ifndef min\n# define min(a,b) (((a)<(b)) ? (a) : (b))\n#endif /* min */\n#ifndef max\n# define max(a,b) (((a)<(b)) ? (b) : (a))\n#endif /* max */\n#ifndef align\n# define align(a) (((ub4)a+(sizeof(void *)-1))&(~(sizeof(void *)-1)))\n#endif /* align */\n#ifndef abs\n# define abs(a)   (((a)>0) ? (a) : -(a))\n#endif\n#define TRUE  1\n#define FALSE 0\n#define SUCCESS 0  /* 1 on VAX */\n\n#endif /* STANDARD */\n","vm.h":"#ifndef __VM_H\n#define __VM_H\n#include \"standard.h\"\n#include \"dict.h\"\n\n#define VMVERSION \"0.32.1\"\n\n// Word Literals\n#define BIGENDUB2(v)        (((v&0x3F)<<8)|((v>>8)&0xFF))\n#define LITERAL(v)          (((v&0x3F)<<8)|((v>>8)&0xFF))\n#define STORELIT(code,pc,v)  { code[pc]=(v>>8)&0x3F; code[pc+1]=v&0xFF; }\n#define STORELIT2(code,pc,v) { code[pc]=0x40|((v>>24)&0x3F); code[pc+1]=(v>>16)&0xFF; code[pc+2]=(v>>8)&0xFF; code[pc+3]=v&0xFF;}\n#define EXTEND(code,pc,mul,add)  { code[pc]=0x80|OP_MULADD; code[pc+1]=(mul<<4)|(add&0xf); }\n\n\n// Code constants (following a command byte)\n#define STOREUB2(code,pc,v)     *(ub2*)(&code[pc])=v;\n#define STORESB2(code,pc,v)     *(sb2*)(&code[pc])=v;\n#define STOREUB4(code,pc,v)     *(ub4*)(&code[pc])=v;\n#define STORESB4(code,pc,v)     *(sb4*)(&code[pc])=v;\n\nextern ub1 vmerror;\nextern void vmraiseerror(ub1);\n\nenum VMERRORS {\n  EOK,\n  ENOTFOUND,\n  ESTACK,\n  ERSTACK,\n  EPC,\n  ESYNTAX,\n  ESYNTAXNUM,\n  ESYNTAXENV,\n  EINDEX,\n  EFCALL,\n  EIO,\n  ENOTIMPLEMENTED,\n  EDATA,\n  EOVERFLOW,\n  ENOSPACE\n};\nenum VMSTATES {\n  VMIDLE  = 0x00,\n  VMRUN   = 0x01,\n  VMEND   = 0x10,\n  VMERROR = 0x20,\n  VMSUSPEND = 0x40,\n};\n\n#if MULTITASKING==1\nstruct frame_s {\n  sw1 bottom;\n  sw1 top;\n  sw1 next;\n  ub1 flags;\n};\ntypedef struct frame_s frame_t;\nextern frame_t frames[];\n#endif\n\n// Event handler\nstruct vmevent_s {\n  ub4 timeout;\n  uw1 *v;\n  uw1  c;\n};\ntypedef struct vmevent_s vmevent_t;\n\n#if MULTITASKING==1\n  struct vmtask_s {\n    ub4 timeout;\n    uw1 *v;\n    uw1  c;\n    uw1 pc;\n    uw1 dstop;\n    uw1 rstop;  \n    uw1 fstop;\n  }\n  typedef struct vmtask_s vmtask_t;\n  extern vmtask_t vmtasks[MAXTASKS];\n  #define TASKREADY   0b11111111111111111111111111111111l\n  #define TASKTIMEOUT 0b01010101010101010101010101010101l\n  #define TASKEVENT   0b10101010101010101010101010101010l\n  // [TM15|TM14|..|TM0]\n  // TM: 00:empty; 01:awaiting timeout 10:awaiting event, 11:ready\n  // Up to 16 tasks\n  extern ub4        vmtaskmask;\n  // Thread table\n  extern ub1        vmtaskcurrent;\n#else\n  // only one \"task\"\n  extern vmevent_t  vmevent;\n#endif\n\n// shared by all tasks, threads, and compiler (and comm. IO)\nextern ub1  CS[];\nextern uw1 cstop; // code sgement pointer\nextern uw1 frtop; // frame table index pointer\nextern sw1 pctop; // current PC\nextern ub1 vmerror;  // error code\nextern ub1 vmstate;  // vm state\nextern ub1 vmbase;   // number base 0:d/1:h/2:b\n\n \nEXTERN void vmreset(void);\n// Return 0: normal exit, <0: error code, >0: timeout in milli seconds\nEXTERN sw1 vmrun(ub2 steps);\n\n#endif\n","vmio.h":"#ifndef __VMIO_H\n#define __VMIO_H\n\n#define DICTNAMELENGTH  8\n\nstruct ios {\n  char name[DICTNAMELENGTH+1];\n  union {\n    void *callback;\n    void *data;\n  };\n  char  type;\n  union {\n    ub2  cells;\n    ub1  args;\n  };\n  union {\n    ub1  size;\n    ub1  argsize;\n  };\n  ub1 retsize;\n};\ntypedef struct ios ios_t;\n\n#define IOSCALLBACK(f) (void (*)())&f\n#define IOSCALLBACKPTR(p) (void (*)())p\n#define IOSDATA(d) (void *)d\n\nextern ub1 iostop;\nextern ios_t ios[];\nEXTERN void iosInit(void);\nEXTERN ub1 fiosAdd(char *name, void (*callback)(), ub1 args, ub1 argsize, ub1 retsize);\nEXTERN ub1 diosAdd(char *name, void *data, ub2 cells, ub1 size);\n\n#define FIOSCALL0(index,...) (*(void (*)())ios[index].callback)(__VA_ARGS__)\n#define FIOSCALL1(index,...) (*(ub1 (*)())ios[index].callback)(__VA_ARGS__)\n#define FIOSCALL2(index,...) (*(ub2 (*)())ios[index].callback)(__VA_ARGS__)\n#define FIOSCALL4(index,...) (*(ub4 (*)())ios[index].callback)(__VA_ARGS__)\n#define DIOSARRAYINDEX(type,index,offset)  (((type* )ios[index].data)[offset])\n#define DIOSDATADEREF(type,index)          (*((type* )ios[index].data))\n#define DIOSDATADPTR(type,index)           ((type* )ios[index].data)\n#endif\n\n","vmloop.h":"#ifndef __VMLOOP_H\n#define __VMLOOP_H\n#include \"vmcode.h\"\n#define DECODE(word) (word&0x80?word&0x7F:word&0x40?OP_TWOLIT:OP_LIT)\n#if VMLOOP==COMPUTEDGOTO\n  #define DISPATCH() PROFILER DEBUG(\"pc=%x ds=%d rs=%d fs=%d op=%x id=%d\\n\",pc,dstop,rstop,fstop,code[pc],DECODE(code[pc])); if ((--steps)==0) goto schedule; goto *dispatch_table[DECODE(code[pc])]\n#endif\n#if VMLOOP==SWITCHCASE\n  #define DISPATCH() PROFILER DEBUG(\"pc=%x ds=%d rs=%d fs=%d op=%x id=%d\\n\",pc,dstop,rstop,fstop,code[pc],DECODE(code[pc])); if ((--steps)==0) goto schedule; break\n#endif\n#if VMLOOP==SWITCHCASEGOTO\n  #define DISPATCH() PROFILER DEBUG(\"pc=%x ds=%d rs=%d fs=%d op=%x id=%d\\n\",pc,dstop,rstop,fstop,code[pc],DECODE(code[pc])); if ((--steps)==0) goto schedule; goto dispatch\n#endif\n#if VMLOOP==FUNCTABLE\n  #define DISPATCH() PROFILER DEBUG(\"pc=%x ds=%d rs=%d fs=%d op=%x id=%d\\n\",pc,dstop,rstop,fstop,code[pc],DECODE(code[pc])); if ((--steps)==0) goto schedule;\n#endif\n#define EXTENDSIGN(v) (v&0x20?v|0xC0:v)\n\n// Main VM loop executing code.\n// Code: CS or any other buffer, pc: CS offset address, steps: maximal number of steps\n// Returns current (next) pc value; if a negative value is returned, then the current op is suspended (e.g., sleep)\n// The vmevent.timeout fields > 0 is the next time when the vmloop may be reentered.\n// If (ub4) vmevent.v is not null, the vmloop may be reentered only if *v==vmevent.c is satisfied\n// if an error occured, vmerror contains the error code\nEXTERN sb2 vmloop(ub1* code, ub2 pc, ub2 steps);\n#endif\n\n","vmsys.h":"#ifndef __VM_SYS_H\n#define __VM_SYS_H\n\n#ifdef SYSCALL\n#define VMMAGICNUM   0xEFAC32BA\n#ifndef VMSYSINIT\n#define VMSYSINIT   pctop=0;\\\n      cstop=0;\\\n      dstop=0;\\\n      rstop=0;\\\n      fstop=0;\n#endif\nenum VMSYSCMDS {\n  VMSYSINIT,\n  VMSYSMAGIC,\n  VMSYSGETENV,\n  VMSYSSETENV,\n  VMSYSCOMPILE,\n  VMSYSRUN,\n  VMSYSLOOP,\n  VMSYSRESET,\n  VMSYSIOSINIT,\n  VMSYSFIOSADD,\n  VMSYSDIOSADD,\n  VMSYSHELLO\n};\nenum VMARGS {\n  VMMAGIC,\n  VMVERS,\n  VMCS,\n  VMCSTOP,\n  VMPCTOP,\n  VMDSTOP,\n  VMRSTOP,\n  VMFSTOP,\n  VMBASE,\n  VMERROR,\n  VMEVENT,\n  \n  VMCONSOLEPRINT,\n  VMCONSOLELINE,\n  VMCONSOLEUPDATE,\n  VMCONSOLESEND,\n  VMCONSOLENL\n};\n\nextern char* (*consoleCurrentLine)(void);\nextern void (*consolePrint)(char *msg);\nextern void (*consoleUpdateLine)(void);\nextern void (*consoleSend)(int v);\nextern void (*consoleNL)(void);\n\nextern u32 vmsysmagic;\nextern u32 vmsys(u16 cmd, u32 arg1, u32 arg2, u32 arg3, u32 arg4, u32 arg5);\n#endif\n\n\nextern ub4 vmMilli(void);\n\n#endif\n\n"},"source":{"compile.c":"/* \n\n  Text-to-bytecode compiler \n  \n  Ver. 1.3.4\n\n  Byetcode compilation is processed in-place! Assumption: text code position is always higher than bytecode pc \n  bytecode Format\n  \n  [CC|6]               Instruction\n  [CC|6][8]            Short Literal\n  [CC|6][8][8][8]      Long  Literal\n  \n  CC  \n  --\n  00 Short 14 Bit constant value\n  01 Long 30 Bit constant value\n  10 Short number command\n  11 Long number command\n  \n  Run: while (pos>=0) pos=compile(code,pos,&pc);\n  \n*/\n\n\n#include \"config.h\"\n#include \"standard.h\"\n#if LEXER == PHLEXER\n#include \"vmwords.h\"\n#include \"lookupa.h\"\n#endif\n#if LEXER == LSTLEXER\n#include \"vmwords.h\"\n#include \"lookupl.h\"\n#endif\n#include \"vm.h\"\n#include \"vmcode.h\"\n#include \"dict.h\"\n#include \"stack.h\"\n#include \"vmio.h\"\n#include \"compile.h\"\n#include <string.h>\n\n// #define ISSEP(c)                (c==' ' || c==0 || c=='\\n')\n#define ISSEP(c)                (c==' ' || c=='\\n')\n#define ISNUM(c)                (c>='0' && c<='9')\n#define SKIPSEP(code,position)  while(ISSEP(code[position])) position++\n#define SKIPSEPCOMMENT(code,position)  { \\\n  ub1 incomm=0;\\\n  while(ISSEP(code[position]) || code[position]=='(' || incomm) {\\\n   if (incomm && code[position]==')') incomm=0;\\\n   else if (!incomm && code[position]=='(') incomm=1;\\\n   position++;\\\n}}\n#define SKIPCOMMENT(code,position)  if (code[position]=='(') { while(code[position] && code[position]!=')') position++; return position+1; }\n\n#ifdef WORDSTRINGS\nOPSTRTABLEGEN\n#endif\n\nstatic ub1 lastop=0,inop=0,dictcurrent=0;\nstatic ub2 env[ENVDEPTH];\nstatic ub1 envtype[ENVDEPTH];\nstatic ub1 envtop=0;\nstatic ub1 vmallocate=0;\n// Upper boundary of locked CS range containing words in global dictionary\nsw1 vmcslocked;\n\n// Temporary dictionary LUT for variables and optionally local words\nstatic dict_cell_t lut[LUTSIZE];\n\nstatic void printWord(char *word,ub1 length) {\n  ub1 i;\n  for(i=0;i<length;i++) {\n    if (!word[i]) break;\n    printf(\"%c\",word[i]);\n  }\n}\nstatic sw2 compileNumber(ub1 *code,sw1 *position) {\n  sw2 v=0; \n  ub1 s=0;\n  if (code[*position]=='-') { s=1; *position+=1; };\n  while (ISNUM(code[*position])) {\n    v*=10;\n    v+=(code[*position]-48);\n    *position+=1; \n  }\n  return s?-v:v;\n}\n\n// Compile one programm code token\n// Generates position independent code (TODO PIC)\n//   All data and most code referencess are relative\nsw1 compileToken(ub1 *code,sw1 position, uw1 *pc) {\n  uw1 h,i,n,start,addr;\n  sw2 v;\n  ub1 cells=0,is_num,sign,len;\n  \n  char *word;\n\n  /* Compile one sourec code word (token) */\n  while (code[position] && ISSEP(code[position])) position++;\n  DEBUG(\"compile pos=%d pc=%d lastop=%x envtop=%d env=%x\\n\",position,*pc,lastop,envtop,envtop?envtype[envtop-1]:OP_NOP);\n  if (code[position]==0) return -1;\n\n  is_num=(ISNUM(code[position]) && (ISNUM(code[position+1]) || ISSEP(code[position+1]) || code[position+1]=='l')) ||\n         (code[position]=='-'  && ISNUM(code[position+1]) && \n          (ISNUM(code[position+2]) || ISSEP(code[position+2]) || code[position+1]=='l'));\n  if (!is_num) { \n    // var ident\n    // array ident #cells\n    // : ident .. ;\n    // Identifier or command\n\n#if COMMENTS==1\n    SKIPCOMMENT(code,position);\n#endif\n    \n    // -1. get identifier\n    word=(char *)&code[position];\n    start=position;\n    while(code[position]!=0 && !ISSEP(code[position])) position++;\n    len=position-start;\n    if (len>8) len=8;\n    DEBUG(\"$ %d start=%d pos=%d pc=%d\\n\",len,start,position,*pc);\n        \n    // 0. Check for pending VAR/ARRAY/DEFINE ops\n#if TWOWORDS==1\n    if (lastop==OP_VAR||lastop==OP_TWOVAR) {\n#else\n    if (lastop==OP_VAR) {\n#endif\n      h=dictadd(lut,LUTSIZE,word,len);\n      if (h==NOTFOUND) { vmerror=ENOSPACE; return -position; }\n      DEBUG(\"LUT + %s\\n\",lut[h].name);\n      len=lastop==OP_VAR?1:2;\n      memset(&code[*pc],0,len*2);\n      lut[h].addr=*pc; // start of data\n      lut[h].size=len*2;\n      // allocate size in-place\n      *pc+=(len*2);\n      lastop=OP_NOP;\n    } else if (lastop==OP_ARRAY) {\n      // array <ident> <numcells>\n      // Non-initialized arrays are appended at the end of the code area (later)\n      // => <array> <-size> <addr> ..\n      // Immediately initialized arrays are placed here\n      // array <ident> { <value1> <value2> ... <valuen> }\n      // => <array> <size> <d1> <d2> .. <dsize> ..\n      SKIPSEP(code,position);\n      if (code[position]=='{') {\n        position++;\n        SKIPSEP(code,position);\n        // reserve space for length field\n        *pc+=2;\n        h=dictadd(lut,LUTSIZE,word,len);\n        if (h==NOTFOUND) { vmerror=ENOSPACE; return -position; }\n        // data start, direct address\n        lut[h].addr=*pc;  \n        // get values, count length\n        n=0;\n        while (code[position] && code[position]!='}') {\n          v=compileNumber(code,&position);\n          // store value (single word for now)\n          STORESB2(code,*pc,v); *pc+=2;\n          SKIPSEPCOMMENT(code,position);\n          n++;\n        }\n        if (code[position]!='}') {\n          vmerror=ESYNTAX;\n          return -position;\n        }\n        position++;\n        lut[h].size=n*2;  // nothing to be allocated at the end, direct address!\n        lut[h].flags|=ARRAY;\n        lastop=OP_NOP;\n        // Size of array in word cell units\n        STORESB2(code,lut[h].addr-2,n);\n      } else if (ISNUM(code[position])) {\n        // reserve space for length field, here negative to indicate no data follows\n        *pc+=2;\n        // but the data address is not known in advance! we need indirect addresing\n        h=dictadd(lut,LUTSIZE,word,len);\n        if (h==NOTFOUND) { vmerror=ENOSPACE; return -position; }\n        lut[h].addr=*pc; // start of address field (filled later)\n        STORESB2(code,*pc,0);\n        *pc+=2;\n        // get number of cells\n        v=compileNumber(code,&position);\n        // Allocate size cells later at the end of code\n        lut[h].size=v*2;  \n        lut[h].flags|=(ALLOCATE|ARRAY|INDIRECT);\n\n        vmallocate++;\n\n        // Store size field (in cell units)\n        STORESB2(code,lut[h].addr-2,-v);\n        lastop=OP_NOP;\n        // indirect addressing\n        // insert size after (sb2) .. \n      } else {\n        vmerror=ESYNTAX;\n        return -position;\n      }\n      lastop=OP_NOP;\n#if DEFINELOCAL==1\n   } else if (lastop==OP_DEFINE || lastop==OP_DEFINECMUL) {\n      // Insert size after (sb2) ..\n      *pc+=2;\n      inop=lastop;\n      if (lastop==OP_DEFINE) {\n        h=dictadd(dictionary,DICTSIZE,word,len);\n        if (h==NOTFOUND) {\n          vmerror=ENOSPACE;\n          return -position;\n        }\n        dictionary[h].addr=*pc;\n        DEBUG(\"def dict %d pos=%d pc=%d\\n\",h,position,*pc);\n        // after ; we can update the branch and the LUT\n        // save dirctionary entry\n        dictcurrent=h;      \n      } else {\n        h=dictadd(lut,LUTSIZE,word,len);\n        if (h==NOTFOUND) {\n          vmerror=ENOSPACE;\n          return -position;\n        }\n        lut[h].addr=*pc;\n        DEBUG(\"def lut %d pos=%d pc=%d\\n\",h,position,*pc);\n        // after ; we can update the branch and the LUT;\n        // save dirctionary entry\n        dictcurrent=h;      \n      }\n      lastop=OP_NOP;\n#else\n   } else if (lastop==OP_DEFINE) {\n      // Insert size after (sb2) ..\n      *pc+=2;\n      // Register or update word in dictionary\n      h=dictadd(dictionary,DICTSIZE,word,len);\n      if (h==NOTFOUND) {\n        vmerror=ENOSPACE;\n        return -position;\n      }\n      dictionary[h].addr=*pc;\n      DEBUG(\"def %d pos=%d pc=%d\\n\",h,position,*pc);\n      // after ; we can update the branch and the LUT;\n      // save dirctionary entry\n      dictcurrent=h;\n      lastop=OP_NOP;\n#endif\n    } else {\n      // 1. Check core word (highest hit probability)\n#if LEXER == PHLEXER\n      h=lookupPH(word,len,CoreLexerTable1,CoreLexerTable1Length,CoreLexerTable2,CoreLexerTable2Length);\n      if (strncmp(word,OPSTRTABLE[h],len)==0) {\n#endif\n#if LEXER == LSTLEXER\n      h=lookupLST(word,len,CoreLexerTable);\n      if (h!=255) { // found word\n#endif\n        // It is a core word\n        DEBUG(\"OPCODE %x (%x)\\n\",h,h+0x80);\n        code[*pc]=h+0x80; *pc+=1;\n        lastop=h;\n        // Handle control ops, the most complex compiler logic\n        switch (h) {\n          case OP_SCSTR:\n          case OP_CDOTCSTR:\n            // find terminating \"\n            position++;\n            while (code[position]!=0 && code[position]!='\"') {\n              code[*pc]=code[position];\n              *pc+=1;\n              position++;\n            }\n            if (code[position]!='\"') { vmerror=ESYNTAX; return -position; };\n            position++;\n            code[*pc-1]=0;\n            break;\n          case OP_DEFRET:\n            // dictcurrent holds last dictionary row index stored by DEFINE; update size field of DEFINE op\n            h=dictcurrent;\n#if DEFINELOCAL==1\n            if (inop==OP_DEFINE) {\n              // global word\n              dictionary[h].size=*pc-dictionary[h].addr-1;\n              *(ub2*)&code[dictionary[h].addr-2]=dictionary[h].size+4; // branch to end of word code (pc+size+4)\n              DEBUG(\"DEFRET %d addr=%d size=%d\\n\",h,dictionary[h].addr,dictionary[h].size); \n              vmcslocked=*pc; \n            } else {\n              // local word\n              lut[h].size=*pc-lut[h].addr-1;\n              *(ub2*)&code[lut[h].addr-2]=lut[h].size+4; // branch to end of word code (pc+size+4)\n              lut[h].flags |= FUNCTION;\n              DEBUG(\"DEFRET %d addr=%d size=%d\\n\",h,dictionary[h].addr,lut[h].size);                \n            }\n#else\n            dictionary[h].size=*pc-dictionary[h].addr-1;\n            *(ub2*)&code[dictionary[h].addr-2]=dictionary[h].size+4; // branch to end of word code (pc+size+4)\n            DEBUG(\"DEFRET %d addr=%d size=%d\\n\",h,dictionary[h].addr,dictionary[h].size);  \n#endif\n            inop=OP_NOP; \n            break;\n          case OP_IF:\n            env[envtop]=*pc;\n            envtype[envtop]=h;\n            envtop++;\n            // reserve branch address \n            *pc+=2;\n            break;\n          case OP_ELSE:\n            if (envtop==0 || envtype[envtop-1]!=OP_IF) { vmerror=ESYNTAXENV; return -position; };\n            addr=env[envtop-1];\n            // remember else for control block end (ENDIF)\n            envtype[envtop-1]=h;\n            env[envtop-1]=*pc;\n            // reserve branch address \n            *pc+=2;\n            // update IF branch address\n            *((ub2*)&code[addr])=*pc;  // Code starts after branch address\n            break;\n          case OP_ENDIF:\n            if (envtop==0 || (envtype[envtop-1]!=OP_IF && envtype[envtop-1]!=OP_ELSE)) { vmerror=ESYNTAXENV; return -position; };\n            envtop--;\n            *pc-=1;  // virtual op\n            // update IF branch address\n            *((ub2*)&code[env[envtop]])=*pc;\n            break;\n          case OP_DO:\n            // DS: b a -- => FS: -- b a\n            // save loop end address immed. for leave\n            *pc+=2;\n            env[envtop]=*pc;\n            envtype[envtop]=h;\n            envtop++;\n            break;\n          case OP_LOOP:\n          case OP_CPLULOOP:\n            if (envtop==0 || envtype[envtop-1]!=OP_DO) { vmerror=ESYNTAXENV; return -position; };\n            envtop--;\n            // FS b a --\n            // increements a; branches to DO if a<b\n            // set LOOP branch address to DO immed.\n            *((ub2*)&code[*pc])=env[envtop];\n            *pc+=2;\n            // update DO branch to end address, too\n            *((ub2*)&code[env[envtop]-2])=*pc;\n            break;\n          case OP_BEGIN:\n            // save loop end address immed. for leaves\n            *pc+=2;\n            env[envtop]=*pc;\n            envtype[envtop]=h;\n            envtop++;\n            break;\n          case OP_AGAIN:\n          case OP_UNTIL:\n            if (envtop==0 || envtype[envtop-1]!=OP_BEGIN) { \n              vmerror=ESYNTAXENV; \n              return -position; \n            };\n            // unconditional loop\n            // set AGAIN branch address to BEGIN immed.\n            *((ub2*)&code[*pc])=env[envtop-1];\n            *pc+=2;\n            // update BEGIN branch to end address, too\n            *((ub2*)&code[env[envtop-1]-2])=*pc;\n            break;\n          case OP_LEAVE:\n            // find next OP_BEGIN/OP_DO\n            i=envtop;\n            while (i && envtype[i-1]!=OP_BEGIN && envtype[i-1]!=OP_DO) i--;\n            if (i==0) { \n              vmerror=ESYNTAXENV; \n              return -position; \n            };\n            // indirect branching, loop end address is later saved here\n            *((ub2*)&code[*pc])=env[i-1]-2;\n            // reserve branch address            \n            *pc+=2;\n            break;\n        }\n        return position;\n      }\n      // 2. Check global code word dictionary\n      h=dictlookup(dictionary,DICTSIZE,word,len);\n      if (h!=NOTFOUND) {\n        DEBUG(\"[%x] DICT CALL %d addr=%d\\n\",*pc,h,dictionary[h].addr);\n        // add call op first (prefix op)\n        code[*pc]=OP_CALL+0x80;\n        // TODO Relative branch?\n        // TODO indirect addressing (always lookup dict on call)?\n        // *(sb2*)(&code[*pc+1])=dictionary[h].addr-*pc; \n        *(ub2*)(&code[*pc+1])=dictionary[h].addr;\n        *pc+=3;\n        if (len<3) position++; // skip white space if len < 3 TODO fails if this was the last word in code!!!\n        return position;\n      }\n      // 3. Check local LUT (data/word?)\n      h=dictlookup(lut,LUTSIZE,word,len);\n      if (h!=NOTFOUND) {\n        DEBUG(\"[%x] LUT var %d addr=%d %c%c%c %c%c%c\\n\",*pc,h,lut[h].addr,lut[h].name[0],lut[h].name[1],lut[h].name[2],word[0],word[1],word[2]);\n        // if it is a variable, push CS address literal\n        if (lut[h].flags & FUNCTION) {\n          DEBUG(\"[%x] LUT CALL %d addr=%d\\n\",*pc,h,dictionary[h].addr);\n          // add call op first (prefix op)\n          code[*pc]=OP_CALL+0x80;\n          // TODO Relative branch?\n          // TODO indirect addressing (always lookup dict on call)?\n          // *(sb2*)(&code[*pc+1])=dictionary[h].addr-*pc; \n          *(ub2*)(&code[*pc+1])=lut[h].addr;\n          *pc+=3;\n          if (len<3) position++; // skip white space if len < 3 TODO fails if this was the last word in code!!!\n          return position;          \n        } else if (lut[h].flags & INDIRECT) {\n          // unintialized arrays\n          // needs indirect address resolution op\n          // address offset is positive (forward)\n          code[*pc]=OP_INDIRECT+0x80; *pc+=1;\n          STOREUB2(code,*pc,lut[h].addr);\n        } else {\n          // Scalar variable or initialized array\n          // LIT is limited to value +8191!\n          // Address value literal\n#if DATAWIDTH==16\n#if CODESIZE<=8192\n          STORELIT(code,*pc,lut[h].addr);\n#else if CODESIZE<=16384\n          if (lut[h].addr<8192) {\n            STORELIT(code,*pc,lut[h].addr);\n          } else {\n            STORELIT(code,*pc,lut[h].addr/2);\n            *pc+=2;\n            // MULADD\n            EXTEND(code,*pc,2,lut[h].addr%2);\n          }\n#else\n #error \"CS size not supported on 16 Bits VM\"\n#endif\n#endif\n        }\n        *pc+=2;\n        return position;      \n      }\n      // 4. Check IOS TODO\n      //    LUT is either linear table or dictionary (perfect hash/lst?)\n      DEBUG(\"IOS top %d\\n\",iostop);\n      for(h=0;h<iostop;h++) {\n        if (strncmp(ios[h].name,word,len)==0 && ios[h].name[len]==0) {\n          DEBUG(\"[%x] IOS %d %c%c%c %c\\n\",*pc,h,ios[h].name[0],ios[h].name[1],ios[h].name[2],ios[h].type);\n          if (ios[h].type=='F') {\n            // fcall\n            code[*pc]=OP_FCALL+0x80;*pc+=1;\n            // -index\n            code[*pc]=(ub1)-(h+1);*pc+=1;\n          } else if (ios[h].type=='D') {\n            // push index (negative value to distiguish from CS addresses)\n            STORELIT(code,*pc,-(h+1));\n            *pc+=2;\n          }\n          return position;\n        }\n      }\n      printWord(word,8); printf(\"\\n\");\n      vmerror=ENOTFOUND;\n      return -position;            \n    }\n  } else {\n    // number\n    // v=0;\n    lastop=OP_NOP;\n    v=compileNumber(code,&position);\n    if (code[position]=='l')  {\n      position++;\n      cells=2;\n    } else cells=1;\n    if (!ISSEP(code[position])) { vmerror=ESYNTAXNUM; return -position; };\n    position++; // one digit numbers can overwrite following separator; skip \n    DEBUG(\"LIT %d cells=%d pos=%d pc=%d\\n\",v,cells,position,*pc);\n    if (cells==1) {\n      /* single number word */\n      /* MSB LSB byte order!!! */\n      if (v>8191 || v<-8192) {\n        if (v>16383 || v<-16384) {\n          STORELIT(code,*pc,v/4);\n          *pc+=2;\n          EXTEND(code,*pc,4,v%4);\n        } else {\n          STORELIT(code,*pc,v/2);\n          *pc+=2;\n          EXTEND(code,*pc,2,v%2);\n        }\n      } else {\n        STORELIT(code,*pc,v);\n      }\n      *pc+=2;\n    } else {\n      /* double number word */\n      /* MSB .. LSB byte order!!! */\n      STORELIT2(code,*pc,v);\n#if 0      \n      code[*pc+3] = v&0xff;\n      v=v>>8;\n      code[*pc+2] = v&0xff;\n      v=v>>8;\n      code[*pc+1] = v&0xff;\n      v=v>>8;\n      code[*pc]   = 0x40 + (v&0x3F);\n#endif\n      *pc+=4;\n    }\n  }\n  return position;\n}\n\n// Interruptable (real-time capable) compiler (steps limits number of compiled tokens in one schedule)\n// steps>=0 : First or full run\n// steps<0  : Following partial runs \n#if COMPILEINCR==1\nsb2 compile(ub1 *code, sb2 position, ub2 *pc, sb2 steps) {\n#else\nsw1 compile(ub1 *code, sw1 position, uw1 *pc) {\n#endif\n  int i,lastpos;\n#if COMPILEINCR==1\n  if (steps>=0) {\n#endif\n    lastpos     = 0;\n    lastop      = OP_NOP;\n    envtop      = 0;\n    vmerror     = EOK;\n    vmallocate  = 0;\n    vmcslocked\t= -1;\n    inop        = OP_NOP;\n    dictinit(lut,LUTSIZE);\n#if COMPILEINCR==1\n  }\n  if (steps>0) steps=-steps;\n#endif\n  while (position>=0) {\n#if COMPILEINCR==1\n    if (steps<0) { steps++; if (steps==0) return position; /* scheduling point reached */ }\n#endif\n    position=compileToken(code,position,pc);\n    if (vmerror!=EOK) break;\n    if (position>=0) lastpos=position;\n  }\n  // compilation failed or finished\n  if (vmerror!=EOK) {\n    PRINT(\"Compiler failed: pos=%d pc=%x err=%d\\n\",-position,*pc,vmerror); return position; \n  } else {\n    if ((code[*pc-1]&0x7F)!=OP_END) {\n      code[*pc]=0x80|OP_END;\n      *pc+=1;\n    }\n  }\n  // Need finally extension of data space at the end of this code frame (non-initialized array data)\n  if (vmallocate) for(i=0;i<LUTSIZE;i++) {\n#if DICTLINEAR==1\n    if (i==dicttop) break;\n#endif\n    if (!vmallocate) break;\n    if (lut[i].flags & ALLOCATE) {\n      lut[i].flags &= ~ALLOCATE;\n      // head: array size in word units\n      STORESB2(code,*pc,lut[i].size/2);\n      *pc+=2;\n      memset(&code[*pc],0,lut[i].size);\n      if (lut[i].flags & ARRAY) {\n        // update (indirect) data address field\n        STORESB2(code,lut[i].addr,*pc);\n      }\n      *pc+=lut[i].size;\n      vmallocate--;\n    }\n  }\n  return position;\n}\n","dict.c":"#include \"config.h\"\n#include \"dict.h\"\n\ndict_cell_t dictionary[DICTSIZE];\n\nstatic ub2 lastfree   = NOTFOUND;\n#if DICTLINEAR!=1\nub2 dictcollision=0;\nstatic ub2 lastindex  = NOTFOUND;\nstatic ub2 lastprev   = NOTFOUND;\n\n// Naive hashing ;but  better than iteration over entire table each time\nub2 dicthash(char *name,ub2 length,ub2 tablesize) {\n  ub2 sum=0,i=0;\n  while (i<length) { sum+=name[i]; i++; };\n  return sum % tablesize;\n}\n\nub2 dicthash_jenkins(char *key, ub2 len, ub2 tablesize)\n{\n  ub4 hash, i;\n  for(hash = i = 0; i < len; ++i)\n  {\n      hash += key[i];\n      hash += (hash << 10);\n      hash ^= (hash >> 6);\n  }\n  hash += (hash << 3);\n  hash ^= (hash >> 11);\n  hash += (hash << 15);\n  return (ub2)(hash % tablesize);    \n}\n\n// Implementation of Murmur hash for 32-bit size_t.\nub2 dicthash_murmur(char* ptr, ub2 len, ub4 seed, ub2 tablesize)\n{\n  ub1 *buf=(ub1 *)ptr;\n  const ub4 m = 0x5bd1e995;\n  ub4 hash = seed ^ len;\n\n  // Mix 4 bytes at a time into the hash.\n  while (len >= 4)\n  {\n    ub4 k = *((ub4 *)buf);\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    buf += 4;\n    len -= 4;\n  }\n\n  // Handle the last few bytes of the input array.\n  switch (len)\n  {\n    case 3:\n      hash ^= ((ub1)buf[2]) << 16;\n    case 2:\n      hash ^= ((ub1)buf[1]) << 8;\n    case 1:\n      hash ^= ((ub1)buf[0]);\n      hash *= m;\n  };\n\n  // Do a few final mixes of the hash.\n  hash ^= hash >> 13;\n  hash *= m;\n  hash ^= hash >> 15;\n  return (ub2)(hash % tablesize);\n}\n\n\n/*\n  Hashtable Dictionary with in-place collision handling\n  and linked collision lists (next hops)\n*/\n// Search for a dictionray entry\nub2 dictlookup(dict_cell_t *dictionary, ub2 dictsize, char *name, ub2 length) {\n  ub2 i,h = dicthash(name,length,dictsize);\n  if (length>DICTNAMELENGTH) length=DICTNAMELENGTH;\n  lastindex = NOTFOUND;\n  lastprev  = NOTFOUND;\n  lastfree  = NOTFOUND;\n  if (dictionary[h].name[0]==0 && !dictionary[h].next) {\n    lastfree=h; return NOTFOUND;\n  } else if (strncmp(dictionary[h].name,name,length)==0 && \n             (length==DICTNAMELENGTH || dictionary[h].name[length]==0)) {\n    return h;\n  } else {\n    lastindex = h;\n    if (dictionary[h].next==0) return NOTFOUND; // fast return\n    // incremental search\n    i=0;\n    while (i<dictsize) {\n      lastprev = h;\n      h=(h+dictionary[h].next)%dictsize;i++;\n      if (strncmp(dictionary[h].name,name,length)==0 && (length==DICTNAMELENGTH || dictionary[h].name[length]==0)) return h;\n      if (dictionary[h].next==0) { lastindex=h; return NOTFOUND; }\n    }\n    return NOTFOUND;\n  } \n}\n//  Add new entry to dictionary or update existing (nop)\nub2 dictadd(dict_cell_t *dictionary, ub2 dictsize, char *name, ub2 length) {\n  ub2 i,h = dicthash(name,length,dictsize);\n  if (length>DICTNAMELENGTH) length=DICTNAMELENGTH;\n  if (dictionary[h].name[0]==0) {\n    // free slot\n    // allocate slot\n    strncpy(dictionary[h].name,name,length);\n    return h;\n  } else {\n    // incremental search for free slot\n    dictcollision++;\n    h=dictlookup(dictionary,dictsize,name,length);\n    if (h!=NOTFOUND) return h; // exists already\n    if (lastfree!=NOTFOUND) {\n      h = lastfree;\n      strncpy(dictionary[h].name,name,length);\n      return h;\n    } else if (lastindex!=NOTFOUND) {\n      h=lastindex;\n      i=0;\n      while (i<dictsize) {\n        h=(h+1)%dictsize;i++;\n        if (dictionary[h].name[0]==0) {\n          dictionary[lastindex].next=h-lastindex;\n          strncpy(dictionary[h].name,name,length);\n          return h;\n        }\n      }\n    }\n    return NOTFOUND;\n  }\n}\n// Remove a dictionary entry\nub2 dictrem(dict_cell_t *dictionary, ub2 dictsize, char *name, ub2 length) {\n  ub2 i,h=dictlookup(dictionary,dictsize,name,length);\n  if (h==NOTFOUND) return NOTFOUND;\n  memset(dictionary[h].name, 0, DICTNAMELENGTH);\n  if (dictionary[h].next && lastprev!=NOTFOUND) {\n    dictionary[lastprev].next=h-lastprev;\n  }\n  return h;\n}\n#endif /* !DICTLINEAR */\n\n#if DICTLINEAR==1\nub2 dicttop    = 0;\n// Search for a dictionray entry\nub2 dictlookup(dict_cell_t *dictionary, ub2 dictsize, char *name, ub2 length) {\n  ub2 h = 0;\n  if (length>DICTNAMELENGTH) length=DICTNAMELENGTH;\n  lastfree=NOTFOUND;\n  while (h<dictsize && h<dicttop) {\n    if (dictionary[h].name[0]==0 && lastfree!=NOTFOUND) lastfree=h;\n    if (strncmp(dictionary[h].name,name,length)==0 && (length==DICTNAMELENGTH || dictionary[h].name[length]==0)) return h;\n    h++;\n  }\n  return NOTFOUND;\n}\n//  Add new entry to dictionary or update existing (nop)\nub2 dictadd(dict_cell_t *dictionary, ub2 dictsize, char *name, ub2 length) {\n  ub2 h=dictlookup(dictionary,dictsize,name,length);\n  if (h==NOTFOUND) {\n    if (lastfree!=NOTFOUND) {\n      h=lastfree;\n      strncpy(dictionary[h].name,name,length);\n      return h;\n    } else if (dicttop!=dictsize) {\n      h=dicttop++;\n      strncpy(dictionary[h].name,name,length);\n      return h;\n    } else return NOTFOUND;\n  } else return h; // exists already\n}\nub2 dictrem(dict_cell_t *dictionary, ub2 dictsize, char *name, ub2 length) {\n  ub2 h=dictlookup(dictionary,dictsize,name,length);\n  if (h==NOTFOUND) return NOTFOUND;\n  memset(dictionary[h].name, 0, DICTNAMELENGTH);\n  return h;\n}\n#endif  /* DICTLINEAR */\n\n// Remove all words in the address range [start,end](CS)\nvoid dictclean(dict_cell_t *dictionary, ub2 dictsize, ub2 start, ub2 end) {\n  ub2 i=0,length;\n  while (i<dictsize) {\n    if (dictionary[i].name[0]==0) continue;\n    if (dictionary[i].addr>=start && dictionary[i].addr<=end) {\n      if (dictionary[i].name[DICTNAMELENGTH-1]!=0) length=DICTNAMELENGTH;\n      else length=strlen(dictionary[i].name);\n      dictrem(dictionary,dictsize,dictionary[i].name,length);\n    }\n  }\n}\nvoid dictinit(dict_cell_t *dictionary, ub2 dictsize) {\n#if DICTLINEAR!=1\n  lastindex  = NOTFOUND;\n  lastprev   = NOTFOUND;\n#endif\n#if DICTLINEAR==1\n  dicttop=0;\n#endif\n  lastfree   = NOTFOUND;\n  memset(dictionary,0,dictsize*sizeof(dict_cell_t));\n}\n","diss.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"compile.h\"\n#include \"dict.h\"\n#include \"stack.h\"\n#include \"vm.h\"\n#include \"vmloop.h\"\n#include \"vmio.h\"\n#include \"vmcode.h\"\n#include \"vmwords.h\"\n\n#include <stdio.h>\n\n// Disassemble code and return number of words (tokens, including literals and plus auxilliray values, e.g., array initializers)\nub2 disassemble(ub2 start, ub2 end) {\n  sw1 pc=start;\n  sw1 addr;\n  uw1 a,i;\n  uw2 da;\n  char *str;\n  ub1 *code=CS;\n  ub1 indef=0;\n  ub2 words=0;\n  ub1 afterend=0;\n  \n  while (pc <= end) {\n    ub1 opcode = DECODE(code[pc]);\n    if (pc>indef) indef=0;\n    if (!afterend) words++;\n    switch (opcode) {\n      case OP_ARRAY     : addr=*(ub2*)(&code[pc+1]);\n                          if (addr<0) {\n                            // Non-initialized data space at code segment end\n                            printf(\"%s%0.4x : %s (%d)\\n\",indef?\"  \":\"\",pc,\"array\",-addr);\n                            pc=pc+5;\n                            words++; // size field\n                          } else {\n                            // Initialized data space following this word\n                            printf(\"%s%0.4x : %s [%d]\\n\",indef?\"  \":\"\",pc,\"array\",addr);\n                            pc=pc+addr*2+3;\n                            words+=(addr);\n                          }\n                          break;\n      case OP_CALL      : addr=*(ub2*)(&code[pc+1]); \n                          printf(\"%s%0.4x : %s (%0.4x)\\n\",indef?\"  \":\"\",pc,\"CALL\",addr); \n                          pc+=3; \n                          break;\n      case OP_CDOLL     : addr=pc;\n                          if ((code[pc+1]&0x7f)==OP_CALL) { \n                            a=*(sb2*)(&code[pc+2]); pc+=4;\n                            printf(\"%s%0.4x : $ (%0.4x)\\n\",indef?\"  \":\"\",addr,a);\n                          } else { \n                            a=*(sb1*)(&code[pc+2]); pc+=3;\n                            printf(\"%s%0.4x : $ (@%0.2x) \",indef?\"  \":\"\",addr,a&0xff);\n                            a=-((sb1)a)-1;\n                            for(i=0;i<DICTNAMELENGTH;i++) {\n                              if (ios[a].name[i]==0) break;\n                              printf(\"%c\",ios[a].name[i]);\n                            }\n                            printf(\"\\n\");\n                          };\n                          break;\n      case OP_CDOTCSTR  : str=(char *)&code[pc+1];\n                          printf(\"%s%0.4x : %s (\\\"%s\\\")\\n\",indef?\"  \":\"\",pc,\".\\\"\",str);\n                          pc=pc+(strlen(str)+2); break;\n      case OP_CPLULOOP  : addr=*(ub2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s (%0.4x)\\n\",indef?\"  \":\"\",pc,\"loop+\",addr); \n                          pc+=3; break;\n      case OP_DEFINE    : addr=*(sb2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s (#%0.4x) $%0.4x-$%0.4x\\n\",indef?\"  \":\"\",pc,\"FUNC\",addr,pc+3,pc+addr-1);\n                          indef=pc+addr-1;\n                          pc+=3;\n                          words++; // function name \n                          break;\n#if DEFINELOCAL==1\n      case OP_DEFINECMUL  : addr=*(sb2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s (#%0.4x) $%0.4x-$%0.4x\\n\",indef?\"  \":\"\",pc,\"FUNC\",addr,pc+3,pc+addr-1);\n                          indef=pc+addr-1;\n                          pc+=3;\n                          words++; // function name  \n                          break;\n#endif\n      case OP_DO        : addr=*(sb2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s (!%0.4x)\\n\",indef?\"  \":\"\",pc,\"do\",addr,pc+addr);\n                          pc+=3; break;\n      case OP_FCALL     : addr=code[pc+1];\n                          printf(\"%s%0.4x : %s (@%0.2x) \",indef?\"  \":\"\",pc,\"FCALL\",addr);\n                          a=-((sb1)addr)-1;\n                          for(i=0;i<DICTNAMELENGTH;i++) {\n                            if (ios[a].name[i]==0) break;\n                            printf(\"%c\",ios[a].name[i]);\n                          } \n                          printf(\"\\n\");\n                          pc+=2; break;\n      case OP_IF        : addr=*(sb2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s ($%0.4x)\\n\",indef?\"  \":\"\",pc,\"if\",addr,pc+addr);\n                          pc+=3; break;\n      case OP_INDIRECT  : addr=*(ub2*)(&code[pc+1]);addr=*(ub2*)(&code[addr]);\n                          printf(\"%s%0.4x : %s (%0.4x)\\n\",indef?\"  \":\"\",pc,\"INDIRECT\",addr); \n                          pc+=3; break;\n      case OP_MULADD    : a=(ub1)(code[pc+1]);\n                          printf(\"%s%0.4x : %s (*%d+(%d))\\n\",indef?\"  \":\"\",pc,\"MULADD\",a>>4,a&0x8?-(8-a&0x7):a&0xf); \n                          pc+=2; break;\n      case OP_LOOP      : addr=*(ub2*)(&code[pc+1]);\n                          printf(\"%s%0.4x : %s (%0.4x)\\n\",indef?\"  \":\"\",pc,\"loop\",addr); \n                          pc+=3; break;\n      case OP_LIT       : a=(ub2)(EXTENDSIGN(code[pc]&0x3F)<<8|code[pc+1]);\n                          printf(\"%s%0.4x : %s (%d)\\n\",indef?\"  \":\"\",pc,\"LIT\",a); \n                          pc+=2; break;\n      case OP_NOP       : printf(\"%s%0.4x : %s\\n\",indef?\"  \":\"\",\"NOP\"); break;\n      case OP_SCSTR  :    str=(char *)&code[pc+1];\n                          printf(\"%s%0.4x : %s (\\\"%s\\\")\\n\",indef?\"  \":\"\",pc,\"s\\\"\",str);\n                          pc=pc+(strlen(str)+2); break;\n      case OP_TWOLIT    : da=(ub4)(EXTENDSIGN(code[pc]&0x3F)<<24|code[pc+1]<<16|code[pc+2]<<8|code[pc+3]);\n                          printf(\"%s%0.4x : %s (%d)\\n\",indef?\"  \":\"\",pc,\"2LIT\",da); \n                          pc+=4; break;\n      case OP_TWOVAR    : addr=pc+1;\n                          printf(\"%s%0.4x : %s $%0.4x\\n\",indef?\"  \":\"\",pc,\"2var\",addr);\n                          pc+=5;\n                          words++; // var name                             \n                          break;\n      case OP_VAR       : addr=pc+1;\n                          printf(\"%s%0.4x : %s $%0.4x\\n\",indef?\"  \":\"\",pc,\"var\",addr);\n                          pc+=3;\n                          words++; // var name  \n                          break;\n      default: {\n        #ifdef WORDSTRINGS\n          const char *opname =  OPSTRTABLE[opcode];\n          printf(\"%s%0.4x : %s\\n\",indef?\"  \":\"\",pc,opname); pc+=1;\n        #else\n          printf(\"%s%0.4x : %0.2x\\n\",indef?\"  \":\"\",pc,opcode); pc+=1;\n        #endif\n      }\n    }\n    if (opcode==OP_END) afterend=1;\n    if (afterend) break;\n  }\n  printf(\"-------------\\n#words=%d\\n-------------\\n\",words);\n  return words;\n}\n","lookupa.c":"/*\n--------------------------------------------------------------------\n--------------------------------------------------------------------\n*/\n#include \"standard.h\"\n#include \"lookupa.h\"\n// Calculates a distinct hash function for a given string. Each value of the\n// integer d results in a different hash value.\nstatic ub4 hash(sb4 d, char *str, ub1 length) {\n  ub1 i;\n  if(d == 0) { d = 0x811c9dc5; }\n  for(i = 0; i < length; i++) {\n    // http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n    // http://isthe.com/chongo/src/fnv/hash_32.c\n    // multiply by the 32 bit FNV magic prime mod 2^32\n    d += (d << 1) + (d << 4) + (d << 7) + (d << 8) + (d << 24);\n    // xor the bottom with the current octet\n    d ^= str[i];\n  }\n  return d & 0x7fffffff;\n};\n\nub1 lookupPH (char *key, ub1 length, sb1* G, ub1 Glength, ub1* V, ub1 Vlength) {\n  sb4 d = G[ hash(0, key, length) % Glength ];\n  if (d < 0) return V[ 0-d-1 ];\n  return V[hash(d, key, length) % Vlength];\n};\n","lookupl.c":"#include \"config.h\"\n#include \"standard.h\"\n\nub1 lookupLST (char *word, ub2 len, ub1 *table) {\n  ub2 pos = ((ub2 *)table)[(len-1)],\n      index = 0;\n      \n   while (index!=len) {\n    // print(index,pos,table[pos],table[pos+1]);\n    if (table[pos]==word[index]) {\n      index++;\n      if (index<len)\n        pos=pos+table[pos+1];   // next node slice start position\n      else return table[pos+1]; // end node, word index\n    } else {\n      pos+=2;\n      if (table[pos]==255) return 255;  // not found\n    }\n  }\n  return 255; // not found\n}\n\n","stack.c":"\n#include \"config.h\"\n#include \"standard.h\"\n#include \"vm.h\"\n#include \"stack.h\"\n\n#if MULTITHREADED==1\n// Data Stack\nsw1 DS[STACKSIZE*MAXTHREADS];\n// Return Stack\nsw1 RS[RSTACKSIZE*MAXTHREADS];\n// Loop stack\nsw1 FS[FSTACKSIZE*MAXTHREADS];\n#else\n// Data Stack\nsw1 DS[STACKSIZE];\n// Return Stack\nsw1 RS[RSTACKSIZE];\n// Loop stack\nsw1 FS[FSTACKSIZE];\n#endif\nuw1 dstop=0,rstop=0,fstop=0;\n\n","vm.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"stack.h\"\n#include \"vm.h\"\n#include \"vmio.h\"\n#include \"vmloop.h\"\n#include \"vmsys.h\"\n\n#ifdef PROFILING\nunsigned int profileops=0;\n#endif\n\n// Default: frame-less incremental mode (current actice code always on the top)\nub1     CS[CODESIZE];\nuw1     cstop=0;\n\n#if MULTITASKING==1\nuw1     frtop=0;\n#endif\n\nsw1     pctop=0;\nub1     vmerror=EOK;\nub1     vmstate=VMIDLE;  // vm state\nub1     vmbase=0;\n// ub4     vmsteps=0;\n\n#if MULTITASKING==1\n  frame_t   frames[FRAMES];\n  // task states for one VM\n  vmtask_t  vmtasks[MAXTASKS];\n  ub4       vmtaskmask=0;\n  ub1       vmthreadcurrent;\n#else\n  vmevent_t vmevent;\n#endif\n\nvoid    *fcalls[8];\nvoid    *io[8];\n\n\nvoid vmraiseerror(ub1 error) {\n  vmerror=error;\n};\n\nvoid vmreset() {\n  #ifdef PROFILING\n    profileops=0;\n  #endif\n  #if MULTITASKING==1\n    vmthreadmask=0;\n    memset((void *)&vmtasks,0,sizeof(vmtask_t)*MAXTASKS);\n  #else\n    vmevent.timeout=0;\n    vmevent.v=NULL;\n  #endif\n  \n  dstop=0;\n  rstop=0;\n  fstop=0;\n}\n\n// Main vmloop execution handler\n// Return 0: normal exit, <0: error code, >0: timeout in milli seconds\nsb2 vmrun (ub2 steps) {\n  ub4 now=vmMilli();\n#if MULTITHREADED==1\n  // modify pctop, and all stack pointers, too!\n#else\n  if (vmevent.timeout && now >= vmevent.timeout) {\n    pctop=-pctop;\n    vmevent.timeout=0;\n  }\n  if (vmevent.v && *vmevent.v == vmevent.c) {\n    pctop=-pctop;\n    vmevent.v=NULL;\n  }\n  if (pctop>=0) pctop = vmloop(CS,(uw1)pctop,steps);\n  if (pctop<0) { \n    /* suspended */\n    now=vmMilli();\n    if (vmevent.timeout) return vmevent.timeout-now;\n  }\n  return vmerror?-vmerror:0;\n#endif  \n}\n\n","vmio.c":"\n#include \"standard.h\"\n#include \"config.h\"\n#include \"vmio.h\"\n\n// linear table; can be replaced with phash\nub1 iostop=0;\nios_t ios[IOSIZE];\n\nvoid iosInit() {\n  memset((void *)&ios[0],0,sizeof(ios_t)*IOSIZE);\n  iostop=0;\n}\n// (name,FIOSCALLBACK(function),01234,0124,0124)\nub1 fiosAdd(char *name, void (*callback)(), ub1 args, ub1 argsize, ub1 retsize) {\n  ios_t *io=&ios[iostop];\n  ub1 length=strlen(name);\n  if (length>DICTNAMELENGTH) length=DICTNAMELENGTH;\n  strncpy(io->name,name,DICTNAMELENGTH);\n  io->type='F';\n  io->callback=(void *)callback;\n  io->args=args;\n  io->argsize=argsize;\n  io->retsize=retsize;\n  iostop++;\n  return iostop-1;\n}\n\n\n\n// (name,IOSDATA(data),01..,124)\nub1 diosAdd(char *name, void *data, ub2 cells, ub1 size) {\n  ios_t *io=&ios[iostop];\n  ub1 length=strlen(name);\n  if (length>DICTNAMELENGTH) length=DICTNAMELENGTH;\n  strncpy(io->name,name,DICTNAMELENGTH);\n  io->type='D';\n  io->data=(void *)data;\n  io->cells=cells;\n  io->size=size;\n  iostop++;\n  return iostop-1;\n}\n\n\n","vmsys.c":"/*\nVM system call API\n\nProgramming and interaction with VM only via vmsys wrapper API\n*/\n#include \"config.h\"\n#include \"standard.h\"\n#include \"vmsys.h\"\n\n#ifdef SYSCALL\nu32 vmsysmagic = VMMAGICNUM;\n\nchar* (*consoleCurrentLine)(void)=NULL;\nvoid (*consolePrint)(char *msg)=NULL;\nvoid (*consoleUpdateLine)(void)=NULL;\nvoid (*consoleSend)(int v)=NULL;\nvoid (*consoleNL)(void)=NULL;\n\n\nu32 vmsys(u16 cmd,u32 arg1,u32 arg2, u32 arg3, u32 arg4, u32 arg5) {\n  char buf[40];\n  switch (cmd) {\n    case VMSYSINIT:\n/*\n      vmsysmagic = VMMAGICNUM;\n      pctop=0;\n      cstop=0;\n      dstop=0;\n      rstop=0;\n      fstop=0;\n*/\n      // Copy the static data initializations\n      VMSYSINIT\n      break;\n    case VMSYSGETENV :   \n      switch (arg1) {\n        case VMMAGIC :  return (u32)VMMAGICNUM;\n        case VMVERS  :  return (u32)VMVERSION;\n        case VMCS    :  return (u32)&CS;\n        case VMPCTOP:   return (u32)&pctop; \n        case VMCSTOP:   return (u32)&cstop; \n        case VMDSTOP:   return (u32)&dstop; \n        case VMRSTOP:   return (u32)&rstop; \n        case VMFSTOP:   return (u32)&fstop; \n        case VMBASE:    return (u32)&vmbase; \n        case VMERROR:   return (u32)&vmerror;\n        case VMEVENT:   return (u32)&vmevent; \n      }\n      break;\n    case VMSYSSETENV :  \n      switch (arg1) {\n        case VMCONSOLEPRINT:  consolePrint=(void (*)(char *msg))arg2; break;\n        case VMCONSOLELINE:   consoleCurrentLine=(char* (*)())arg2; break;\n        case VMCONSOLEUPDATE: consoleUpdateLine=(void (*)())arg2; break;\n        case VMCONSOLESEND:   consoleSend=(void (*)())arg2; break;\n        case VMCONSOLENL:     consoleNL=(void (*)())arg2; break;\n      }\n      return 0;\n      break;\n    case VMSYSCOMPILE : return compile(CS,(sb2) /* position */ arg1, (ub2 *) arg2 /* *pc */);\n    case VMSYSRUN     : return vmrun((ub2) arg1 /* steps */);\n    case VMSYSLOOP    : return vmloop(CS, (ub2) arg1 /* pc */, (ub2) arg2 /*steps*/);\n    case VMSYSRESET   : vmreset(); return 0; \n    case VMSYSIOSINIT : iosInit(); return 0;\n    case VMSYSFIOSADD : return (u32) fiosAdd((char *)arg1 /* char *name */,\n                                             IOSCALLBACKPTR(arg2),\n                                             (ub1)arg3,\n                                             (ub1)arg4,\n                                             (ub1)arg5);\n    case VMSYSDIOSADD : return (u32) diosAdd((char *)arg1 /* char *name */,\n                                             IOSDATA(arg2),\n                                             (ub2)arg3,\n                                             (ub1)arg4);\n    default: return 0;\n  }\n  return 0;\n}\n#endif\n\n// Wrapper for system millisecond clock returning current (ub4) millisecods\nub4 vmMilli(void){\n#ifdef MILLI\nMILLI\n#else\n  return 0;\n#endif\n}\n\n"},"words":["dup","2dup","drop","2drop","swap","2swap","over","2over","rot","2rot","-dup","pick",">f","f>","f","fdrop","fpick",">r","r>","r","+","2+","-","2-","*","2*","/","2/","mod","2mod","max","2max","min","2min","abs","2abs","minus","2minus","and","2and","or","2or","xor","2xor","=","2=","<","2<",">","2>","0<","0=",".",".\"",".s","2.","cr","@","2@","s@","s\"","!","2!","s!","2ext","2red","$","cell+","array",":",":*",";","return","do","loop","+loop","leave","i","j","if","else","endif","begin","again","until","while","var","2var","const","forget","send","sendn","receive","read","write","load","save","out","inp","sleep","yield","base","one","await","end"],"ops":{"ABS":"STACKCHECK(1);a=POP();\nPUSH(a<0?-a:a);\npc++;DISPATCH(); /* abs */","AGAIN":"pc=(*(ub2*)(&code[pc+1]));\nDISPATCH(); /* again */","AND":"STACKCHECK(2);a=POP();b=POP();PUSH((sb2)((ub2)a & (ub2)b));\npc++;DISPATCH(); /* and */","ARRAY":"DEBUG(\"ARRAY BRANCH %dn\",(*(sb2*)(&code[pc+1])));\na=*((sb2*)&code[pc+1]); if (a<0) pc=pc+5; else pc=pc+a*2+3;\nDISPATCH(); /* array */","AWAIT":"STACKCHECK(2);addr=POP();a=POP();\nif (ios[addr].type!='D') { vmerror=EIO; goto onerror; };\nvmevent.v=&DIOSDATADEREF(ub2,addr);\nvmevent.c=a;\npc++;goto suspend; /* await */","BASE":"STACKCHECK(1);vmbase=POP();\npc++;DISPATCH(); /* base */","BEGIN":"pc+=3;DISPATCH(); /* begin */","BRANCH":"pc=(*(ub2*)(&code[pc+1]));DISPATCH();","BRANCHZ":"a=POP();if (a==0) pc=(*(ub2*)(&code[pc+1])); else pc+=3;DISPATCH();","CALL":"addr=*(ub2*)(&code[pc+1]);\nDEBUG(\"CALL %dn\",a);\nRPUSH(pc+3);\npc=addr;DISPATCH(); /* call */","CDOLL":"if ((code[pc+1]&0x7f)==OP_CALL) { a=*(sb2*)(&code[pc+2]); pc+=4;}\nelse { a=*(sb1*)(&code[pc+2]); pc+=3; };\nPUSH(a); DISPATCH(); /* $ */","CDOT":"STACKCHECK(1); CONSOLEFMT(vmbase==0?\"%d \":\"%x \",vmbase==0?(sb2)POP():(ub2)POP()); pc++;\nDISPATCH(); /* . */","CDOTCSTR":"char *str=(char *)&code[pc+1];CONSOLE(str);\npc+=(strlen(str)+2);DISPATCH(); /* .\" */","CDOTS":"STACKCHECK(1);a=POP();b=a/2+a%2;\nSTACKCHECK(b);for(c=1;c<=b;c++) { ub2 cc=(ub2)POP(); CONSOLEFMT(\"%c\",(cc>>8)&0xFF); CONSOLEFMT(\"%c\",cc&0xFF);}\nif (a%2==0) CONSOLEFMT(\"%c\",' ');\npc++;DISPATCH(); /* .s */","CELLCPLU":"STACKCHECK(2);a=POP();addr=POP();PUSH(addr+a*2);\npc++;DISPATCH(); /* cell+ */","CEQ":"STACKCHECK(2);a=POP();b=POP();PUSH(a==b?1:0);\npc++;DISPATCH(); /* = */","CGT":"STACKCHECK(2);a=POP();b=POP();PUSH(b>a?1:0);\npc++;DISPATCH(); /* > */","CGTF":"STACKCHECK(1);a=POP();FPUSH(a);\npc++;DISPATCH(); /* >f */","CGTR":"STACKCHECK(1);a=POP();RPUSH(a);\npc++;DISPATCH(); /* >r */","CLT":"STACKCHECK(2);a=POP();b=POP();PUSH(b<a?1:0);\npc++;DISPATCH(); /* < */","CMIN":"STACKCHECK(2);a=POP();b=POP();PUSH(b-a);\npc++;DISPATCH(); /* - */","CMINDUP":"STACKCHECK(1);a=STACKTOP(1);PUSH(a);PUSH(a);\npc++;DISPATCH(); /* -dup */","CMINROT":"STACKCHECK(3);c=POP();b=POP();a=POP();\nPUSH(c);PUSH(a);PUSH(b);\npc++;DISPATCH(); /* -rot */","CMUL":"STACKCHECK(2);a=POP();b=POP();PUSH(a*b);\npc++;DISPATCH(); /* * */","CONST":"pc++;DISPATCH(); /* const */","CPLU":"STACKCHECK(2);a=POP();b=POP();PUSH(a+b);\npc++;DISPATCH(); /* + */","CPLULOOP":"STACKCHECK(1);FSTACKCHECK(2);FSTACKTOP(1)+=(POP());\nif (FSTACKTOP(1)<FSTACKTOP(2)) pc=(*(ub2*)(&code[pc+1])); else { FPOP2(); pc+=3; };\nDISPATCH(); /* +loop */","CQUESTDUP":"STACKCHECK(1);if (STACKTOP(1)!=0) { a=STACKTOP(1);PUSH(a); };\npc++;DISPATCH(); /* -dup */","CQUO":"STACKCHECK(2);a=POP();b=POP();PUSH(b/a);\npc++;DISPATCH(); /* / */","CR":"CONSOLENL();\npc++;DISPATCH(); /* cr */","DEFINE":"DEBUG(\"DEFINE BRANCH %dn\",(*(sb2*)(&code[pc+1])));\npc=pc+(*(sb2*)(&code[pc+1]));DISPATCH(); /* : */","DEFINECMUL":"DEBUG(\"DEFINE BRANCH %dn\",(*(sb2*)(&code[pc+1])));\npc=pc+(*(sb2*)(&code[pc+1]));DISPATCH(); /* :* */","DEFRET":"DEBUG(\"RETURNn\");\nRSTACKCHECK(1);pc=RPOP();\nDISPATCH(); /* return */","DO":"STACKCHECK(2);FPUSH2U(POP2U());\npc+=3;DISPATCH(); /* do */","DROP":"STACKCHECK(1);POP();\npc++;DISPATCH(); /* drop */","DUP":"STACKCHECK(1);a=STACKTOP(1);\nPUSH(a);\npc++;DISPATCH(); /* dup */","ELSE":"pc=(*(ub2*)(&code[pc+1]));\nDISPATCH(); /* else */","END":"goto end; /* end */","ENDIF":"pc++;DISPATCH(); /* endif */","F":"FSTACKCHECK(1);a=FSTACKTOP(1);PUSH(a)\npc++;DISPATCH(); /* f */","FCALL":"#if DATAWIDTH==16\n/* must be adapated to all possible FIOS calles!*/\npc++;addr=(-(sb1)code[pc])-1;\nif (addr>IOSIZE || ios[addr].type!='F') { vmerror=EFCALL; goto onerror; };\nif (ios[addr].argsize==2) switch (ios[addr].args) {\ncase 1: STACKCHECK(1); a=POP(); break;\ncase 2: STACKCHECK(2); b=POP(); a=POP(); break;\ncase 3: STACKCHECK(3); c=POP(); b=POP(); a=POP(); break;\ncase 4: STACKCHECK(4); d=POP(); c=POP(); b=POP(); a=POP(); break;\ncase 8: STACKCHECK(7); h = POP(); g=POP(); f=POP(); e=POP(); d=POP(); c=POP(); b=POP(); a=POP(); break;\n}\nif (ios[addr].argsize==4) switch (ios[addr].args) {\ncase 1: STACKCHECK(2); da=POP2(); break;\ncase 2: STACKCHECK(4); db=POP2(); da=POP2(); break;\ncase 3: STACKCHECK(6); dc=POP2(); db=POP2(); da=POP2(); break;\ncase 4: STACKCHECK(8); dd=POP2(); dc=POP2(); db=POP2(); da=POP2(); break;\n}\nif (ios[addr].retsize==0 && ios[addr].argsize<4) switch (ios[addr].args) {\ncase 0: FIOSCALL0(addr); break;\ncase 1: FIOSCALL0(addr,a); break;\ncase 2: FIOSCALL0(addr,a,b); break;\ncase 3: FIOSCALL0(addr,a,b,c); break;\ncase 4: FIOSCALL0(addr,a,b,c,d); break;\ncase 8: FIOSCALL0(addr,a,b,c,d,e,f,g,h); break;\n}\nelse if (ios[addr].retsize==0 && ios[addr].argsize==4) switch (ios[addr].args) {\ncase 1: FIOSCALL0(addr,da); break;\ncase 2: FIOSCALL0(addr,da,db); break;\ncase 3: FIOSCALL0(addr,da,db,dc); break;\ncase 4: FIOSCALL0(addr,da,db,dc,dd); break;\n}\nelse if (ios[addr].retsize==2 && (ios[addr].argsize==2||ios[addr].args==0)) switch (ios[addr].args) {\ncase 0: PUSH(FIOSCALL2(addr)); break;\ncase 1: PUSH(FIOSCALL2(addr,a)); break;\ncase 2: PUSH(FIOSCALL2(addr,a,b)); break;\ncase 3: PUSH(FIOSCALL2(addr,a,b,c)); break;\ncase 4: PUSH(FIOSCALL2(addr,a,b,c,d)); break;\n}\nelse if (ios[addr].retsize==4 && (ios[addr].argsize==2||ios[addr].args==0)) switch (ios[addr].args) {\ncase 0: PUSH2(FIOSCALL4(addr)); break;\ncase 1: PUSH2(FIOSCALL4(addr,a)); break;\ncase 2: PUSH2(FIOSCALL4(addr,a,b)); break;\ncase 3: PUSH2(FIOSCALL4(addr,a,b,c)); break;\ncase 4: PUSH2(FIOSCALL4(addr,a,b,c,d)); break;\n}\nelse if (ios[addr].retsize==0 && (ios[addr].argsize==4||ios[addr].args==0)) switch (ios[addr].args) {\ncase 0: FIOSCALL0(addr); break;\ncase 1: FIOSCALL0(addr,da); break;\ncase 2: FIOSCALL0(addr,da,db); break;\ncase 3: FIOSCALL0(addr,da,db,dc); break;\ncase 4: FIOSCALL0(addr,da,db,dc,dd); break;\n}\nelse if (ios[addr].retsize==2 && (ios[addr].argsize==4||ios[addr].args==0)) switch (ios[addr].args) {\ncase 0: PUSH(FIOSCALL2(addr)); break;\ncase 1: PUSH(FIOSCALL2(addr,da)); break;\ncase 2: PUSH(FIOSCALL2(addr,da,db)); break;\ncase 3: PUSH(FIOSCALL2(addr,da,db,dc)); break;\ncase 4: PUSH(FIOSCALL2(addr,da,db,dc,dd)); break;\n}\nelse if (ios[addr].retsize==4 && (ios[addr].argsize==4||ios[addr].args==0)) switch (ios[addr].args) {\ncase 0: PUSH2(FIOSCALL4(addr)); break;\ncase 1: PUSH2(FIOSCALL4(addr,da)); break;\ncase 2: PUSH2(FIOSCALL4(addr,da,db)); break;\ncase 3: PUSH2(FIOSCALL4(addr,da,db,dc)); break;\ncase 4: PUSH2(FIOSCALL4(addr,da,db,dc,dd)); break;\n}\nif (vmerror) goto onerror; pc++;DISPATCH(); /* fcall */\n#endif","FCGT":"FSTACKCHECK(1);a=FPOP();PUSH(a);\npc++;DISPATCH(); /* f> */","FDROP":"STACKCHECK(1);a=POP();FSTACKCHECK(a);fstop-=a;\npc++;DISPATCH(); /* f */","FETCH":"STACKCHECK(1);addr=(ub2)POP();\nPUSH(*((sb2*)&code[addr]));\npc++;DISPATCH(); /* @ */","FORGET":"vmerror=ENOTIMPLEMENTED; goto onerror;\n /* forget */","FPICK":"STACKCHECK(1);b=POP();FSTACKCHECK(b);a=FSTACKTOP(b);PUSH(a)\npc++;DISPATCH(); /* f */","I":"FSTACKCHECK(2);PUSH(FSTACKTOP(1));\npc++;DISPATCH(); /* i */","IF":"STACKCHECK(1); a=POP(); if (a==0) pc=(*(ub2*)(&code[pc+1])); else pc+=3;\nDISPATCH(); /* if */","INDIRECT":"addr=*(ub2*)(&code[pc+1]);addr=*(ub2*)(&code[addr]);PUSH(addr);\npc=pc+3;DISPATCH();","INP":"pc++;DISPATCH(); /* inp */","J":"FSTACKCHECK(4);PUSH(FSTACKTOP(3));\npc++;DISPATCH(); /* j */","LEAVE":"addr=*(ub2*)(&code[pc+1]);\nDEBUG(\"LEAVE %x %xn\",addr,*(ub2*)(&code[addr]));\nif (DECODE(code[addr-1])==OP_DO) FPOP2();\naddr=*(ub2*)(&code[addr]);\npc=addr;\nDISPATCH(); /* leave */","LIT":"DEBUG(\"LIT %xn\",EXTENDSIGN((code[pc]&0x3F)<<8)|code[pc+1]);\nPUSH((sb2)((EXTENDSIGN(code[pc]&0x3F)<<8)|code[pc+1])); pc+=2;\nDISPATCH();","LOAD":"vmerror=ENOTIMPLEMENTED; goto onerror;\n /* load */","LOOP":"FSTACKCHECK(2);FSTACKTOP(1)+=1;\nif (FSTACKTOP(1)<FSTACKTOP(2)) pc=(*(ub2*)(&code[pc+1])); else { FPOP2(); pc+=3; }\nDISPATCH(); /* loop */","MAX":"STACKCHECK(2);a=POP();b=POP();PUSH(b>a?b:a);\npc++;DISPATCH(); /* max */","MIN":"STACKCHECK(2);a=POP();b=POP();PUSH(b<a?b:a);\npc++;DISPATCH(); /* min */","MINUS":"STACKCHECK(1);a=POP();\nPUSH(-a);\npc++;DISPATCH(); /* minus */","MOD":"STACKCHECK(1);a=POP();b=POP();PUSH(b%a);\npc++;DISPATCH(); /* mod */","MULADD":"ub1 v=(ub1)code[pc+1]; STACKCHECK(1); \nif (v&0x8) STACKTOP(1)=STACKTOP(1)*(v>>4)-(8-v&0x7); \nelse STACKTOP(1)=STACKTOP(1)*(v>>4)+(v&0x7);\npc+=2;DISPATCH(); /* MULADD */","NIP":"STACKCHECK(2);a=POP();POP();\nPUSH(a);\npc++;DISPATCH(); /* nip */","NOP":"pc++;DISPATCH();","ONE":"PUSH(1);\npc++;DISPATCH(); /* one */","OR":"STACKCHECK(2);a=POP();b=POP();PUSH((sb2)((ub2)a | (ub2)b));\npc++;DISPATCH(); /* or */","OUT":"STACKCHECK(1); OUT(POP());\npc++;DISPATCH(); /* out */","OVER":"STACKCHECK(2);a=STACKTOP(2);PUSH(a);\npc++;DISPATCH(); /* over */","PICK":"STACKCHECK(1);b=POP();STACKCHECK(b);a=STACKTOP(b);PUSH(a)\npc++;DISPATCH(); /* f */","R":"RSTACKCHECK(1);a=RSTACKTOP(1);PUSH(a)\npc++;DISPATCH(); /* r */","RCGT":"RSTACKCHECK(1);a=RPOP();PUSH(a);\npc++;DISPATCH(); /* r> */","READ":"STACKCHECK(1);addr=(ub2)(-POP()-1);\nif (addr>=IOSIZE || ios[addr].type!='D') { vmerror=EIO; goto onerror; };\nif (ios[addr].cells) { STACKCHECK(1); a=POP();\nif (a<0 || a>=ios[addr].cells) { vmerror=EINDEX; goto onerror; };\nswitch (ios[addr].size) {\ncase 1: PUSH(DIOSARRAYINDEX(ub1,addr,a));   break;\ncase 2: PUSH(DIOSARRAYINDEX(sb2,addr,a));   break;\ncase 4: PUSH2(DIOSARRAYINDEX(sb4,addr,a));  break;\n}\n} else {\nswitch (ios[addr].size) {\ncase 1: PUSH(DIOSDATADEREF(ub1,addr));   break;\ncase 2: PUSH(DIOSDATADEREF(sb2,addr));   break;\ncase 4: PUSH2(DIOSDATADEREF(sb4,addr));  break;\n}\n}\npc++;DISPATCH(); /* read */","RECEIVE":"vmerror=ENOTIMPLEMENTED; goto onerror;\n /* receive */","RETURN":"DEBUG(\"RETURNn\");\nRSTACKCHECK(1);pc=RPOP();\nDISPATCH(); /* ; */","ROT":"STACKCHECK(3);c=POP();b=POP();a=POP();\nPUSH(b);PUSH(c);PUSH(a);\npc++;DISPATCH(); /* rot */","SAVE":"vmerror=ENOTIMPLEMENTED; goto onerror;\n /* save */","SCSTR":"ub1 *str=(ub1 *)&code[pc+1];a=strlen((char*)str);b=a/2+a%2;\nfor(c=b-1;c>=0;c--) PUSH((str[c*2]<<8)+str[c*2+1]); PUSH(a);\npc+=(a+2);DISPATCH(); /* s\" */","SEND":"STACKCHECK(2); a=POP(); b=POP();SEND(a,b);\npc++;DISPATCH(); /* send */","SENDN":"STACKCHECK(3); addr=POP(); a=POP(); b=POP(); SENDN(addr,a,b);\npc++;DISPATCH(); /* send */","SFETCH":"STACKCHECK(1);addr=(ub2)POP();a=*((sb2*)&code[addr]);b=a/2+a%2;\nfor(c=b;c>0;c--) PUSH(((sb2*)&code[addr])[c]); PUSH(a);\npc++;DISPATCH(); /* s@ */","SLEEP":"STACKCHECK(1); a=POP(); vmevent.timeout=vmMilli()+a;\npc++;goto suspend; /* sleep */","SSTORE":"STACKCHECK(2);addr=(ub2)POP();a=POP();b=a/2+a%2;\nSTACKCHECK(b);*((sb2*)&code[addr])=a;\nfor(c=1;c<=b;c++) ((ub2*)&code[addr])[c]=(ub2)POP();\npc++;DISPATCH(); /* s! */","STORE":"STACKCHECK(2);addr=(ub2)POP();a=POP();\n*((sb2*)&code[addr])=a;\npc++;DISPATCH(); /* ! */","SWAP":"STACKCHECK(2);a=POP();b=POP();\nPUSH(a);PUSH(b);\npc++;DISPATCH(); /* swap */","TUCK":"STACKCHECK(2);a=POP();POP();\nPUSH(a);\npc++;DISPATCH(); /* tuck */","TWOABS":"STACKCHECK(2);da=POP2();\nPUSH2(da<0?-da:da);\npc++;DISPATCH(); /* 2abs */","TWOAND":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da&db);\npc++;DISPATCH(); /* 2and */","TWOCDOT":"STACKCHECK(2);CONSOLEFMT(vmbase==0?\"%d \":\"%x \",vmbase==0?(sb4)POP2():(ub4)POP2());\npc++;DISPATCH(); /* 2. */","TWOCEQ":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH(da==db?1:0);\npc++;DISPATCH(); /* 2= */","TWOCGT":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH(db>da?1:0);\npc++;DISPATCH(); /* 2> */","TWOCGTR":"STACKCHECK(2);da=POP2();RPUSH2(da);\npc++;DISPATCH(); /* 2>r */","TWOCLT":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH(db<da?1:0);\npc++;DISPATCH(); /* 2< */","TWOCMIN":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(db-da);\npc++;DISPATCH(); /* 2- */","TWOCMUL":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da*db);\npc++;DISPATCH(); /* 2* */","TWOCPLU":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da+db);\npc++;DISPATCH(); /* 2+ */","TWOCQUO":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(db/da);\npc++;DISPATCH(); /* 2/ */","TWODROP":"STACKCHECK(2);POP2();\npc++;DISPATCH(); /* 2drop */","TWODUP":"STACKCHECK(2);da=STACKTOP2(1);\nPUSH2(da);\npc++;DISPATCH(); /* 2dup */","TWOEXT":"STACKCHECK(1);a=POP();PUSH2((sb4)a);\npc++;DISPATCH(); /* 2ext */","TWOFETCH":"STACKCHECK(1);addr=(ub2)POP();\nPUSH2(*((sb4*)&code[addr]));\npc++;DISPATCH(); /* 2@ */","TWOLIT":"DEBUG(\"TWOLIT %xn\",EXTENDSIGN((code[pc]&0x3F)<<24)|(code[pc+1]<<16)|(code[pc+2]<<8)|code[pc+3]);\nPUSH2((ub4)(EXTENDSIGN((code[pc]&0x3F)<<24)|(code[pc+1]<<16)|(code[pc+2]<<8)|code[pc+3])); pc+=4;\nDISPATCH();","TWOMAX":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(db>da?db:da);\npc++;DISPATCH(); /* 2max */","TWOMIN":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(db<da?db:da);\npc++;DISPATCH(); /* 2min */","TWOMINUS":"STACKCHECK(2);da=POP2();\nPUSH2(-da);\npc++;DISPATCH(); /* 2minus */","TWOMOD":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(db%da);\npc++;DISPATCH(); /* 2mod */","TWOOR":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da|db);\npc++;DISPATCH(); /* 2or */","TWOOVER":"STACKCHECK(4);da=STACKTOP2(2);PUSH2(da);\npc++;DISPATCH(); /* 2over */","TWOR":"RSTACKCHECK(2);da=RSTACKTOP2(1);PUSH2(da);\npc++;DISPATCH(); /* 2r */","TWORCGT":"RSTACKCHECK(2);da=RPOP2();PUSH2(da);\npc++;DISPATCH(); /* r> */","TWORED":"STACKCHECK(2);da=POP2();PUSH((sb2)da);\npc++;DISPATCH(); /* 2red */","TWOROT":"STACKCHECK(6);dc=POP2();db=POP2();da=POP2();\nPUSH2(db);PUSH2(dc);PUSH2(da);\npc++;DISPATCH(); /* 2rot */","TWOSTORE":"STACKCHECK(3);addr=(ub2)POP();da=POP2();\n*((sb4*)&code[addr])=da;\npc++;DISPATCH(); /* 2! */","TWOSWAP":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da);PUSH2(db);pc++;DISPATCH(); /* 2swap */","TWOVAR":"pc+=5;DISPATCH(); /* 2var */","TWOXOR":"STACKCHECK(4);da=POP2();db=POP2();\nPUSH2(da^db);\npc++;DISPATCH(); /* 2xor */","UNTIL":"STACKCHECK(1);a=POP();\nif (a) pc+=3; else pc=(*(ub2*)(&code[pc+1]));\nDISPATCH(); /* until */","VAR":"pc+=3;DISPATCH(); /* var */","WHILE":"STACKCHECK(1);a=POP();\nif (a==0) pc+=3; else pc=(*(ub2*)(&code[pc+1]));\npc++;DISPATCH(); /* while */","WRITE":"STACKCHECK(1);addr=(ub2)(-POP()-1);\nif (addr>=IOSIZE || ios[addr].type!='D') { vmerror=EIO; goto onerror; };\nif (ios[addr].cells) { STACKCHECK(1); a=POP();\nif (a<0 || a>=ios[addr].cells) { vmerror=EINDEX; goto onerror; };\nswitch (ios[addr].size) {\ncase 1: STACKCHECK(1); DIOSARRAYINDEX(ub1,addr,a)=(ub1)POP(); break;\ncase 2: STACKCHECK(1); DIOSARRAYINDEX(sb2,addr,a)=POP();      break;\ncase 4: STACKCHECK(2); DIOSARRAYINDEX(sb4,addr,a)=POP2();     break;\n}\n} else {\nswitch (ios[addr].size) {\ncase 1: STACKCHECK(1); DIOSDATADEREF(ub1,addr)=(ub1)POP();    break;\ncase 2: STACKCHECK(1); DIOSDATADEREF(sb2,addr)=POP();         break;\ncase 4: STACKCHECK(2); DIOSDATADEREF(sb4,addr)=POP2();        break;\n}\n}\npc++;DISPATCH(); /* write */","XOR":"STACKCHECK(2);a=POP();b=POP();PUSH((sb2)((ub2)a ^ (ub2)b));\npc++;DISPATCH(); /* xor */","YIELD":"DEBUG(\"yield\\n\"); pc++; goto end; /* yield */","ZEROCEQ":"STACKCHECK(1);a=POP();PUSH(a==0?1:0);\npc++;DISPATCH(); /* 0= */","ZEROCLT":"STACKCHECK(1);a=POP();PUSH(a<0?1:0);\npc++;DISPATCH(); /* 0< */"},"sys":{"MILLI":"  // ub4 vmMilli() { .. }\n  long long milli;\n  struct timeval tv;\n  gettimeofday(&tv,NULL);\n  milli=(((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);\n  return (ub4)milli;","esp32":{"macros":{},"constants":{},"source":{},"header":{}},"readline":{"macros":{},"constants":{},"source":{"readline.c":"/*\n**\n**    PROTECTED BY AND DISTRIBUTED UNDER THE TERMS OF: \n**    Free Software Foundation-Europe, GNU GPL License, Version 2\n**\n**    $MODIFIEDBY:  BLAB\n**    $AUTHORS:     Stefan Bosse\n**    $INITIAL:     (C) 1986 - 1993, 1996   Thomas Williams, Colin Kelley\n**    $CREATED:     \n**    $MODIFIED:    \n**    $VERSION:     1.03\n**\n**    $INFO:\n**\n** NANO-EMACS line editing facility \n** printable characters print as themselves (insert not overwrite) \n** ^A moves to the beginning of the line \n** ^B moves back a single character \n** ^E moves to the end of the line \n** ^F moves forward a single character \n** ^K kills from current position to the end of line \n** ^P moves back through history \n** ^N moves forward through history \n** ^H and DEL delete the previous character \n** ^D deletes the current character, or EOF if line is empty \n** ^L/^R redraw line in case it gets trashed \n** ^U kills the entire line \n** ^W kills last word \n** LF and CR return the entire line regardless of the cursor postition \n** EOF with an empty line returns (char *)NULL \n**\n** all other characters are ignored \n**\n**\n**    $ENDOFINFO\n**\n*/\n\n\n/*\n** Copyright (C) 1986 - 1993, 1996   Thomas Williams, Colin Kelley\n**\n** Permission to use, copy, and distribute this software and its\n** documentation for any purpose with or without fee is hereby granted, \n** provided that the above copyright notice appear in all copies and \n** that both that copyright notice and this permission notice appear \n** in supporting documentation.\n**\n** Permission to modify the software is granted, but not the right to\n** distribute the modified code.  Modifications are to be distributed \n** as patches to released version.\n**  \n** This software is provided \"as is\" without express or implied warranty.\n** \n**\n** AUTHORS\n**\n**   Original Software:\n**     Tom Tkacik\n**\n**   Msdos port and some enhancements:\n**     Gershon Elber and many others.\n**\n**   Some more changes:\n**     Stefan Bosse     \n** \n*/\n\n\n\n/* \n** A small portable version of GNU's readline \n** This is not the BASH or GNU EMACS version of READLINE.\n** Do not need any terminal capabilities except backspace, \n** and space overwrites a character.\n*/\n\n\n\n#define _INTERNAL\n#include \"readline.h\"\n\n/*\n** define characters to use with our input character handler \n*/\nstatic char term_chars[NCCS];\n\nstatic int term_set = 0;    /* =1 if rl_termio set */\n\n#define special_getc() ansi_getc()\nstatic int ansi_getc __PROTO((void));\n\n\n\n#define MAXBUF      1024    /* initial size and increment of input line length */\n#define BACKSPACE   0x08    /* ^H */\n#define SPACE       ' '\n#define NEWLINE     '\\n'\n\nstruct hist {\n    char *line;\n    struct hist *prev;\n    struct hist *next;\n};\n\nstatic struct hist *history = NULL;  /* no history yet */\nstatic struct hist *cur_entry = NULL;\n\nstatic char *cur_line;  /* current contents of the line */\nstatic int line_len=0;\nstatic int cur_pos = 0; /* current position of the cursor */\nstatic int max_pos = 0; /* maximum character position */\n\n\nstatic void fix_line __PROTO((void));\nstatic void redraw_line __PROTO((char *prompt));\nstatic void clear_line __PROTO((char *prompt));\nstatic void clear_eoline __PROTO((void));\nstatic void copy_line __PROTO((char *line));\nstatic void set_termio __PROTO((void));\nstatic void reset_termio __PROTO((void));\nstatic int ansi_getc __PROTO((void));\nstatic char user_getc __PROTO((void));\nstatic int user_putc __PROTO((int ch));\nstatic int user_puts __PROTO((char *str));\nstatic void backspace __PROTO((void));\nstatic void extend_cur_line __PROTO((void));\n\n/*\n** user_putc and user_puts should be used in the place of\n** fputc(ch,stderr) and fputs(str,stderr) for all output\n** of user typed characters.  \n*/\n\nstatic char\nuser_getc()\n{\n    char my_c;\n    read(STDOUT_FILENO,&my_c,1);\n    return my_c;\n}\n\nstatic int\nuser_putc(ch)\nint ch;\n{\n    int rv;\n    rv = write(STDOUT_FILENO,&ch,1);\n    return rv;\n}\n\nstatic int\nuser_puts(str)\nchar *str;\n{\n    int rv;\n    rv = write(STDOUT_FILENO,str,strlen(str));\n    return rv;\n}\n\n/*\n** This function provides a centralized non-destructive backspace capability \n**\n** M. Castro \n*/\n\nstatic void\nbackspace()\n{\n    user_putc(BACKSPACE);\n}\n\nstatic void extend_cur_line()\n{\n  char *new_line;\n\n  /*\n  ** extent input line length \n  */\n  new_line=ralloc(cur_line, line_len+MAXBUF, NULL);\n  if(!new_line) {\n    reset_termio();\n    int_error(\"Can't extend readline length\", NO_CARET);\n  }\n  cur_line=new_line;\n  line_len+=MAXBUF;\n\n\n#ifdef DEBUG_STR\n  fprintf(stderr, \"\\nextending readline length to %d chars\\n\", line_len);\n#endif\n}\n\nchar *\nreadline(prompt)\nchar *prompt;\n{\n\n    int cur_char;\n    char *new_line;\n\n    /* start with a string of MAXBUF chars */\n    \n    if(line_len!=0) {\n        free(cur_line);\n        line_len=0;\n    }\n\n    cur_line=alloc((unsigned long)MAXBUF, \"readline\");\n    line_len=MAXBUF;\n\n    /*\n    ** set the termio so we can do our own input processing \n    */\n    set_termio();\n\n    /* print the prompt */\n\n    user_puts(prompt);\n\n    cur_line[0] = '\\0';\n    cur_pos = 0;\n    max_pos = 0;\n    cur_entry = NULL;\n\n    /* get characters */\n    for(;;) {\n        cur_char = special_getc();\n    /*\n    ** The #define CHARSET7BIT should be used when one encounters problems with\n    ** 8bit characters that should not be entered on the commandline. I cannot\n    ** think on any reasonable example where this could happen, but what do I know?\n    ** After all, the unix world still ignores 8bit chars in most applications.\n    **\n    ** Note that latin1 defines the chars 0x80-0x9f as control chars. For the\n    ** benefit of Atari, MSDOS, Windows and NeXT I have decided to ignore this,\n    ** since it would require more #ifs.\n    **\n    */\n\n#ifdef CHARSET7BIT\n        if(isprint(cur_char)) {\n#else  /* CHARSET7BIT */\n        if(isprint(cur_char) || (((unsigned char)cur_char > 0x7f) &&\n                     cur_char != EOF)) {\n#endif /* CHARSET7BIT */\n            int i;\n\n            if(max_pos+1>=line_len) {\n                extend_cur_line();\n            }\n\n            for(i=max_pos; i>cur_pos; i--) {\n                cur_line[i] = cur_line[i-1];\n            }\n            user_putc(cur_char);\n            cur_line[cur_pos] = cur_char;\n            cur_pos += 1;\n            max_pos += 1;\n            if (cur_pos < max_pos)\n                fix_line();\n            cur_line[max_pos] = '\\0';\n\n        /* else interpret unix terminal driver characters */\n#ifdef VERASE\n        } else if(cur_char == term_chars[VERASE] ){  /* DEL? */\n            if(cur_pos > 0) {\n                int i;\n                cur_pos -= 1;\n                backspace();\n                for(i=cur_pos; i<max_pos; i++)\n                    cur_line[i] = cur_line[i+1];\n                max_pos -= 1;\n                fix_line();\n            }\n#endif /* VERASE */\n#if defined(VEOF) \n        } else if(cur_char == term_chars[VEOF] ){   /* ^D? */\n            if(max_pos == 0) {\n                reset_termio();\n                return((char *)NULL);\n            }\n            if((cur_pos < max_pos)&&(cur_char == 004)) { /* ^D */\n                int i;\n                for(i=cur_pos; i<max_pos; i++)\n                    cur_line[i] = cur_line[i+1];\n                max_pos -= 1;\n                fix_line();\n            }\n#endif /* VEOF */\n#ifdef VKILL\n        } else if(cur_char == term_chars[VKILL] ){  /* ^U? */\n            clear_line(prompt);\n#endif /* VKILL */\n#ifdef VWERASE\n        } else if(cur_char == term_chars[VWERASE] ){  /* ^W? */\n            while((cur_pos > 0) &&\n                  (cur_line[cur_pos-1] == SPACE)) {\n                cur_pos -= 1;\n                backspace();\n            }\n            while((cur_pos > 0) &&\n                  (cur_line[cur_pos-1] != SPACE)) {\n                cur_pos -= 1;\n                backspace();\n            }\n            clear_eoline();\n            max_pos = cur_pos;\n#endif /* VWERASE */\n#ifdef VREPRINT\n        } else if(cur_char == term_chars[VREPRINT] ){  /* ^R? */\n            user_putc(NEWLINE); /* go to a fresh line */\n            redraw_line(prompt);\n#endif /* VREPRINT */\n#ifdef VSUSP\n        } else if(cur_char == term_chars[VSUSP]) {\n            reset_termio();\n\n#ifndef AMOEBA_RAW\n            kill(0, SIGTSTP);\n#endif\n            /* process stops here */\n\n            set_termio();\n            /* print the prompt */\n            redraw_line(prompt);\n#endif /* VSUSP */\n        } else {\n            /* do normal editing commands */\n            /* some of these are also done above */\n            int i;\n            switch(cur_char) {\n                case EOF:\n                reset_termio();\n                return((char *)NULL);\n                case 001: /* ^A */\n                while(cur_pos > 0) {\n                    cur_pos -= 1;\n                    backspace();\n                }\n                break;\n                case 002: /* ^B */\n                if(cur_pos > 0) {\n                    cur_pos -= 1;\n                    backspace();\n                }\n                break;\n                case 005: /* ^E */\n                while(cur_pos < max_pos) {\n                    user_putc(cur_line[cur_pos]);\n                    cur_pos += 1;\n                }\n                break;\n                case 006: /* ^F */\n                if(cur_pos < max_pos) {\n                    user_putc(cur_line[cur_pos]);\n                    cur_pos += 1;\n                }\n                break;\n                case 013: /* ^K */\n                clear_eoline();\n                max_pos = cur_pos;\n                break;\n                case 020: /* ^P */\n                if(history != NULL) {\n                    if(cur_entry == NULL) {\n                        cur_entry = history;\n                        clear_line(prompt);\n                        copy_line(cur_entry->line);\n                    } else if(cur_entry->prev != NULL) {\n                        cur_entry = cur_entry->prev;\n                        clear_line(prompt);\n                        copy_line(cur_entry->line);\n                    }\n                }\n                break;\n                case 016: /* ^N */\n                if(cur_entry != NULL) {\n                    cur_entry = cur_entry->next;\n                    clear_line(prompt);\n                    if(cur_entry != NULL) \n                        copy_line(cur_entry->line);\n                    else\n                        cur_pos = max_pos = 0;\n                }\n                break;\n                case 014: /* ^L */\n                case 022: /* ^R */\n                user_putc(NEWLINE); /* go to a fresh line */\n                redraw_line(prompt);\n                break;\n                case 0177: /* DEL */\n                case 010: /* ^H */\n                if(cur_pos > 0) {\n                    cur_pos -= 1;\n                    backspace();\n                    for(i=cur_pos; i<max_pos; i++)\n                        cur_line[i] = cur_line[i+1];\n                    max_pos -= 1;\n                    fix_line();\n                }\n                break;\n                case 004: /* ^D */\n                if(max_pos == 0) {\n                    reset_termio();\n                    return((char *)NULL);\n                }\n                if(cur_pos < max_pos) {\n                    for(i=cur_pos; i<max_pos; i++)\n                        cur_line[i] = cur_line[i+1];\n                    max_pos -= 1;\n                    fix_line();\n                }\n                break;\n                case 025:  /* ^U */\n                clear_line(prompt);\n                break;\n                case 027:  /* ^W */\n                while((cur_pos > 0) &&\n                      (cur_line[cur_pos-1] == SPACE)) {\n                    cur_pos -= 1;\n                    backspace();\n                }\n                while((cur_pos > 0) &&\n                      (cur_line[cur_pos-1] != SPACE)) {\n                    cur_pos -= 1;\n                    backspace();\n                }\n                clear_eoline();\n                max_pos = cur_pos;\n                break;\n                case '\\n': /* ^J */\n                cur_line[max_pos+1] = '\\0';\n\n                user_putc(NEWLINE);\n                new_line = (char *)ralloc(cur_line, (unsigned long)(strlen(cur_line)+1), \"line resize\");\n                line_len=0;\n#ifdef DEBUG_STR\n                fprintf(stderr, \"Resizing input line to %d chars\\n\", strlen(new_line));\n#endif\n                reset_termio();\n                return(new_line);\n                default:\n                break;\n            }\n        }\n    }\n}\n\n/*\n** fix up the line from cur_pos to max_pos \n** do not need any terminal capabilities except backspace, \n** and space overwrites a character \n*/\nstatic void\nfix_line()\n{\n    int i;\n\n    /* write tail of string */\n    for(i=cur_pos; i<max_pos; i++)\n        user_putc(cur_line[i]);\n\n    /* write a space at the end of the line in case we deleted one */\n    user_putc(SPACE);\n\n    /* backup to original position */\n    for(i=max_pos+1; i>cur_pos; i--)\n        backspace();\n\n}\n\n/*\n** redraw the entire line, putting the cursor where it belongs \n*/\nstatic void\nredraw_line(prompt)\nchar *prompt;\n{\n    int i;\n\n    user_puts(prompt);\n    user_puts(cur_line);\n\n    /* put the cursor where it belongs */\n    for(i=max_pos; i>cur_pos; i--)\n        backspace();\n}\n\n/*\n** clear cur_line and the screen line \n*/\nstatic void\nclear_line(prompt)\nchar *prompt;\n{\n    int i;\n    for(i=0; i<max_pos; i++)\n        cur_line[i] = '\\0';\n\n    for(i=cur_pos; i>0; i--)\n        backspace();\n\n    for(i=0; i<max_pos; i++)\n        user_putc(SPACE);\n\n    user_putc('\\r');\n    user_puts(prompt);\n\n    cur_pos = 0;\n    max_pos = 0;\n}\n\n/*\n** clear to end of line and the screen end of line \n*/\nstatic void\nclear_eoline()\n{\n    int i;\n    for(i=cur_pos; i<max_pos; i++)\n        cur_line[i] = '\\0';\n\n    for(i=cur_pos; i<max_pos; i++)\n        user_putc(SPACE);\n    for(i=cur_pos; i<max_pos; i++)\n        backspace();\n}\n\n/*\n** copy line to cur_line, draw it and set cur_pos and max_pos \n*/\nstatic void\ncopy_line(line)\nchar *line;\n{\n    while(strlen(line)+1>line_len) {\n        extend_cur_line();\n    }\n    strcpy(cur_line, line);\n    user_puts(cur_line);\n    cur_pos = max_pos = strlen(cur_line);\n}\n\n/*\n** add line to the history \n*/\nvoid \nadd_history(line)\nchar *line;\n{\n    struct hist *entry;\n    entry = (struct hist *)alloc((unsigned long)sizeof(struct hist),\"history\");\n    entry->line = alloc((unsigned long)(strlen(line)+1),\"history\");\n    strcpy(entry->line, line);\n\n    entry->prev = history;\n    entry->next = NULL;\n    if(history != NULL) {\n        history->next = entry;\n    }\n    history = entry;\n}\n\n\n/*\n** Convert ANSI arrow keys to control characters \n*/\n\nstatic int\nansi_getc()\n{\n \n  int c;   \n  \n  fflush(stdout);\n  fflush(stderr);\n\n  c = user_getc();\n\n#ifdef AMOEBA\n    if(c==-1)\n        return 4 /* ^D */;  \n#endif\n\n  if (c == 033) {\n\n            \n    c = user_getc(); /* check for CSI */\n    if (c == '[') {\n\n\n      c = user_getc(); /* get command character */\n\n      switch (c) {\n      case 'D': /* left arrow key */\n        c = 002;\n        break;\n      case 'C': /* right arrow key */\n        c = 006;\n        break;\n      case 'A': /* up arrow key */\n        c = 020;\n        break;\n      case 'B': /* down arrow key */\n        c = 016;\n        break;\n      }\n    }\n  }\n  return c;\n}\n\n\n/*\n** set termio so we can do our own input processing \n*/\nstatic int restore_on_exit=0;\n\nstatic void\nset_termio()\n{\n#if !defined(AMOEBA) && !defined(_Windows) \n/*\n** set termio so we can do our own input processing \n** and save the old terminal modes so we can reset them later \n*/\n    if(term_set == 0) \n    {\n        if (restore_on_exit==0)\n        {\n            /*\n            ** On exit make sure that the original terminal \n            ** state is restored\n            */\n            atexit(reset_termio);\n            restore_on_exit=1;\n        };\n\n        /*\n         * Get terminal modes.\n         */\n#ifdef SGTTY\n        ioctl(0, TIOCGETP, &orig_termio);\n#else  /* SGTTY */\n#ifdef TERMIOS\n#ifdef TCGETS\n        ioctl(0, TCGETS, &orig_termio);\n#else\n        tcgetattr(0, &orig_termio);\n#endif /* TCGETS */\n#else\n        ioctl(0, TCGETA, &orig_termio);\n#endif /* TERMIOS */\n#endif /* SGTTY */\n\n        /*\n         * Save terminal modes\n         */\n        rl_termio = orig_termio;\n\n        /*\n         * Set the modes to the way we want them\n         *  and save our input special characters\n         */\n#ifdef SGTTY\n        rl_termio.sg_flags |= CBREAK;\n        rl_termio.sg_flags &= ~(ECHO|XTABS);\n        ioctl(0, TIOCSETN, &rl_termio);\n\n        ioctl(0, TIOCGETC, &s_tchars);\n        term_chars[VERASE]   = orig_termio.sg_erase;\n        term_chars[VEOF]     = s_tchars.t_eofc;\n        term_chars[VKILL]    = orig_termio.sg_kill;\n#ifdef TIOCGLTC\n        ioctl(0, TIOCGLTC, &s_ltchars);\n        term_chars[VWERASE]  = s_ltchars.t_werasc;\n        term_chars[VREPRINT] = s_ltchars.t_rprntc;\n        term_chars[VSUSP]    = s_ltchars.t_suspc;\n\n        /* disable suspending process on ^Z */\n        s_ltchars.t_suspc = 0;\n        ioctl(0, TIOCSLTC, &s_ltchars);\n#endif /* TIOCGLTC */\n#else  /* SGTTY */\n        rl_termio.c_iflag &= ~(BRKINT|PARMRK|INPCK|IUCLC|IXON|IXOFF);\n        rl_termio.c_iflag |=  (IGNBRK|IGNPAR);\n        /* rl_termio.c_oflag &= ~(ONOCR); Costas Sphocleous Irvine,CA */\n\n        rl_termio.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL|NOFLSH);\n\n        rl_termio.c_lflag |=  (ISIG);\n        rl_termio.c_cc[VMIN] = 1;\n        rl_termio.c_cc[VTIME] = 0;\n\n#ifndef VWERASE\n#define VWERASE 3\n#endif\n        term_chars[VERASE]   = orig_termio.c_cc[VERASE];\n        term_chars[VEOF]     = orig_termio.c_cc[VEOF];\n        term_chars[VKILL]    = orig_termio.c_cc[VKILL];\n#ifdef TERMIOS\n        term_chars[VWERASE]  = orig_termio.c_cc[VWERASE];\n#ifdef VREPRINT\n        term_chars[VREPRINT] = orig_termio.c_cc[VREPRINT];\n#else\n#ifdef VRPRNT\n        term_chars[VRPRNT] = orig_termio.c_cc[VRPRNT];\n#endif\n#endif\n        term_chars[VSUSP]    = orig_termio.c_cc[VSUSP];\n\n        /* disable suspending process on ^Z */\n        rl_termio.c_cc[VSUSP] = 0;\n#endif /* TERMIOS */\n#endif /* SGTTY */\n\n        /*\n         * Set the new terminal modes.\n         */\n#ifdef SGTTY\n        ioctl(0, TIOCSLTC, &s_ltchars);\n#else\n#ifdef TERMIOS\n#ifdef TCSETSW\n        ioctl(0, TCSETSW, &rl_termio);\n#else\n        tcsetattr(0, TCSADRAIN, &rl_termio);\n#endif /* TCSETSW */\n#else\n        ioctl(0, TCSETAW, &rl_termio);\n#endif /* TERMIOS */\n#endif /* SGTTY */\n        term_set = 1;\n    }\n\n#endif /* !AMOEBA && !_Windows */\n\n#ifdef AMOEBA\n    tcgetattr(0,&orig_termio);\n    rl_termio=orig_termio;\n    rl_termio.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL|NOFLSH);\n    tcsetattr(0,TCSANOW,&rl_termio);\n    term_set=1;\n#endif\n\n}\n  \nstatic void\nreset_termio()\n{\n#ifndef _Windows\n    /*\n    ** reset saved terminal modes \n    */\n    if(term_set == 1) {\n#ifdef SGTTY\n        ioctl(0, TIOCSETN, &orig_termio);\n#ifdef TIOCGLTC\n        /* enable suspending process on ^Z */\n        s_ltchars.t_suspc = term_chars[VSUSP];\n        ioctl(0, TIOCSLTC, &s_ltchars);\n#endif /* TIOCGLTC */\n#else  /* SGTTY */\n#ifdef TERMIOS\n#ifdef TCSETSW\n        ioctl(0, TCSETSW, &orig_termio);\n#else\n#ifndef AMOEBA\n        tcsetattr(0, TCSADRAIN, &orig_termio);\n#else\n        tcsetattr(0, TCSANOW, &orig_termio);\n\n#endif\n#endif /* TCSETSW */\n#else\n        ioctl(0, TCSETAW, &orig_termio);\n#endif /* TERMIOS */\n#endif /* SGTTY */\n\n        term_set = 0;\n    }\n#endif /* !_Windows */\n}\n\n"},"header":{"readline.h":"\n/*\n** get prototypes or declarations for string and stdlib functions and deal\n** with missing functions like strchr. \n*/\n\n/*\n** we will assume the ANSI/Posix/whatever situation as default.\n** the header file is called string.h and the index functions are called\n** strchr, strrchr. Exceptions have to be listed explicitly \n*/\n\n#ifndef STDFN_H\n#define STDFN_H\n\n/* External API */\nextern char *readline(char *prompt);\nextern void  add_history(char *line);\n\n#ifdef _INTERNAL\n/* Internal Stuff */\n\n#ifdef _WIN32\n#define _Windows\n#include <winio.h>\n#endif\n\n#ifdef __unix__\n#define HAS_POPEN\n#define HAS_UNISTD\n#define HAS_STRNCASECMP\n#endif\n\n#ifdef __linux__\n#ifndef LINUX\n #define LINUX\n#endif\n#endif\n\n\n#include <ctype.h>\n#include <signal.h>\n\n\n#include <stdio.h>\n#include <setjmp.h>\n\n#ifdef HAVE_PROTO\n  #define __PROTO(a)    a\n#else\n  #define __PROTO(a)    ()\n#endif\n\n#ifdef HAS_UNISTD\n  #define HAVE_UNISTD_H\n#endif\n#ifdef HAS_POPEN\n  #define HAVE_POPEN\n#endif\n#ifdef HAS_STRNCASECMP\n  #define HAVE_STRNCASECMP\n#endif\n\n\n#define alloc(a,b)      malloc(a)\n#define ralloc(a,b,c)  realloc(a,b)\n\n#define int_error(a,b)  {printf(\"%s\\n\",a);return;}\n\n\n\n#ifdef sequent\n#define NO_STRCHR\n#endif\n\n#ifndef NO_STRING_H\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n\n#ifdef NO_STRCHR\n#ifdef strchr\n#undef strchr\n#endif\n#define strchr index\n#ifdef strrchr\n#undef strrchr\n#endif\n#define strrchr rindex\n#endif\n\n#ifdef NO_STDLIB_H\nchar *malloc();\nchar *realloc();\nchar *getenv();\nint system();\ndouble atof();\nint atoi();\nlong atol();\ndouble strtod();\n#else\n#include <stdlib.h>\n#endif\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#else\n#ifdef HAVE_LIBC_H /* NeXT uses libc instead of unistd */\n#include <libc.h>\n#endif\n#endif\n\n#ifndef NO_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef EXTERN_ERRNO\nextern int errno;\n#endif\n\n#ifndef NO_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#ifndef NO_LIMITS_H\n#include <limits.h>\n#else\n#ifdef HAVE_VALUES_H\n#include <values.h>\n#endif\n#endif\n\n#ifdef NEED_TIME_T\n#define time_t unsigned long\n#endif\n\n#include <time.h> /* ctime etc, should also define time_t and struct tm */\n\n#ifndef HAVE_POPEN\n  FILE *popen(char *cmd, char *mode);\n  int pclose(FILE *pipe);\n#endif\n\n#ifndef NO_LOCALE_H\n  #include <locale.h>\n#endif\n\n#ifndef HAVE_STRNICMP\n#  ifdef HAVE_STRNCASECMP\n#    define strnicmp strncasecmp\n#  else\n#    define NEED_STRNICMP\nint strnicmp __PROTO((char *s1, char *s2, int n));\n#  endif\n#endif\n\n\n#ifndef GP_GETCWD\n#  if defined(HAVE_GETCWD)\n#   define GP_GETCWD(path,len) getcwd (path, len)\n#  else\n#   define GP_GETCWD(path,len) getwd (path)\n#  endif\n#endif\n\n#define NO_CARET (-1)\n\n\n#ifdef LINUX /* HBB: to get prototype for ioctl() */\n  #include <sys/ioctl.h>\n#endif\n\n#ifdef HAVE_TERMIOS_H\n# ifdef HAVE_TCGETATTR\n#  define TERMIOS\n# endif\n#else\n# ifdef HAVE_SGTTY_H\n#  define SGTTY\n# endif\n#endif\n\n\n/*\n** Set up structures using the proper include file\n*/\n#if defined(_IBMR2) || defined(alliant)\n  #define SGTTY\n#endif\n\n/*\n**  submitted by Francois.Dagorn@cicb.fr \n*/\n#ifdef SGTTY\n  #include <sgtty.h>\n  static struct sgttyb orig_termio, rl_termio;\n  /*\n  ** define terminal control characters \n  */\n  static struct tchars s_tchars;\n  #ifndef VERASE\n    #define VERASE    0\n  #endif\n  #ifndef VEOF\n    #define VEOF      1\n  #endif\n  #ifndef VKILL\n    #define VKILL     2\n  #endif\n  #ifdef TIOCGLTC\t\t \n  /*\n  ** available only with the 'new' line discipline \n  */\n    static struct ltchars s_ltchars;\n    #ifndef VWERASE\n      #define VWERASE   3\n    #endif\n    #ifndef VREPRINT\n      #define VREPRINT  4\n    #endif\n    #ifndef VSUSP\n      #define VSUSP     5\n    #endif\n  #endif /* TIOCGLTC */\n\n  #ifndef NCCS\n    #define NCCS      6\n  #endif\n\n#else /* SGTTY */\n\n/*\n** SIGTSTP defines job control \n** if there is job control then we need termios.h instead of termio.h \n** (Are there any systems with job control that use termio.h?  I hope not.) \n*/\n\n  #if defined(SIGTSTP) || defined(TERMIOS)\n    #ifndef TERMIOS\n      #define TERMIOS\n    #endif\n    #include <termios.h>\n    /*\n    ** Added by Robert Eckardt, RobertE@beta.TP2.Ruhr-Uni-Bochum.de \n    */\n    #ifdef ISC22\n      #ifndef ONOCR\t\t\t/* taken from sys/termio.h */\n        #define ONOCR 0000020\t/* true at least for ISC 2.2 */\n      #endif \n      #ifndef IUCLC\n        #define IUCLC 0001000\n      #endif\n    #endif /* ISC22 */\n    #if !defined(IUCLC)\n      #define IUCLC 0 /* translate upper to lower case not supported */\n    #endif\n\n    static struct termios orig_termio, rl_termio;\n  #else\n    #ifndef _Windows\n      #include <termio.h>\n      static struct termio orig_termio, rl_termio;\n      /*\n      ** termio defines NCC instead of NCCS \n      */\n      #define NCCS    NCC\n    #else \n      #define NCCS    6\n    #endif\n  #endif /* SIGTSTP */\n#endif /* SGTTY */\n\n/*\n** ULTRIX defines VRPRNT instead of VREPRINT \n*/\n#if defined(VRPRNT) && !defined(VREPRINT)\n  #define VREPRINT VRPRNT\n#endif\n#endif\n\n\n#endif /* STDFN_H */"}},"stm32":{"macros":{},"constants":{"ARDUINO":"#define DEBUG(...)           \n#define PRINT(...)           { char buf[200]; sprintf(buf,__VA_ARGS__); serialPrint(buf); }\n#define CONSOLE(msg)         { char buf[200]; sprintf(buf,\"%s\",msg); serialPrint(buf); }\n#define CONSOLEFMT(...)      { char buf[200]; sprintf(buf,__VA_ARGS__); serialPrint(buf); }\n#define CONSOLELINE(msg)     { char buf[200]; sprintf(buf,\"%s\",msg); serialPrintNL(buf); }\n#define CONSOLELINEFMT(...)  { char buf[200]; sprintf(buf,__VA_ARGS__); serialPrintNL(buf); }\n#define CONSOLENL()          { serialPrintNL(\"\"); }\n#define OUT(v)               { char buf[50]; sprintf(buf,\"$%04x\",(ub2)v); serialPrint(buf); } \n#define SEND(dst,v)          { char buf[50]; sprintf(buf,\"$%02x:%04x\",dst,(ub2)v); serialPrint(buf); }\n#define SENDN(dst,n,addr)    {char buf[50]; int i;sprintf(buf,\"$%02x:%02x:\",dst,(ub2)n);serialPrint(buf);\\\n                                            for(i=0;i<n;i++) { sprintf(buf,\"%04x\",((ub2*)&CS[addr])[i]); serialPrint(buf);}}"},"source":{"main.templ.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"compile.h\"\n#include \"dict.h\"\n#include \"stack.h\"\n#include \"vm.h\"\n#include \"vmloop.h\"\n#include \"vmio.h\"\n#include \"vmwords.h\"\n\n#if DSP==1\n#include \"fpsin.h\"\n#include \"fplog10.h\"\n#include \"fpsigmoid.h\"\n#include \"fpvec.h\"\n#endif\n\n// use CONSOLEFMT, CONSOLELINE, or PRINT macros for output \n#pragma IGNORE\n\nstatic int execute(char *text) {\n  sb2 pos;\n  uw1 cstop0=cstop;\n  memcpy(&CS[cstop0],text,strlen(text));\n  cstop=strlen(text);\n  CS[cstop]=0;\n  cstop++;\n  // printf(\"%s [%d]\\n\",path,cstop);\n  pos=pctop=(sb2)cstop0;\n#if COMPILEINCR==1\n  pos=compile(&CS[cstop0],pos,(uw1*)&pctop,0);\n#else\n  pos=compile(&CS[cstop0],pos,(uw1*)&pctop);\n#endif\n  if (vmerror!=EOK) {\n    PRINT(\"Compilation failed with error %d at character position %d\\n\",vmerror,-pos);\n    return -1;\n  }\n  // printf(\"Code size: %d Byte(s)\\n\",pctop);    \n  pctop=0;\n  vmstate=0;\n  while (vmstate!=VMEND && !vmerror) pctop=vmloop(CS,(uw1)pctop,1000);\n  PRINT(\"END pc=%x state=%x ds=%d rs=%d fs=%d err=%d\\n\",pctop,vmstate,dstop,rstop,fstop,vmerror);\n  return vmerror;\n}\n\n/*\nint main() {\n   execute(\"1 2 . cr end\");\n}\n\n*/"},"header":{}},"unix":{"macros":{"MILLI":"  // ub4 vmMilli() { .. }\n  long long milli;\n  struct timeval tv;\n  gettimeofday(&tv,NULL);\n  milli=(((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);\n  return (ub4)milli;"},"constants":{},"source":{"main.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"compile.h\"\n#include \"dict.h\"\n#include \"stack.h\"\n#include \"vm.h\"\n#include \"vmloop.h\"\n#include \"vmio.h\"\n#include \"vmsys.h\"\n#include \"vmwords.h\"\n#include \"diss.h\"\n\n#include <stdio.h>\n\n#if DSP==1\n#include \"fprelu.h\"\n#include \"fpsin.h\"\n#include \"fplog10.h\"\n#include \"fpsigmoid.h\"\n#include \"fpvec.h\"\n#endif\n\n#if READLINE==1\n#include \"readline.h\"\n#endif\n\nchar *VMERRORNAME[] = {\n  \"EOK\",\n  \"ENOTFOUND\",\n  \"ESTACK\",\n  \"ERSTACK\",\n  \"EPC\",\n  \"ESYNTAX\",\n  \"ESYNTAXNUM\",\n  \"ESYNTAXENV\",\n  \"EINDEX\",\n  \"EFCALL\",\n  \"EIO\",\n  \"ENOTIMPLEMENTED\",\n  \"EDATA\",\n  \"EOVERFLOW\",\n  \"ENOSPACE\"\n};\n\nub2 myData2[100];\nub1 myData1[100];\nub2 myCounter=0;\nub2 mySample[8192];\n\nub1 test=0,\n    profile=0,\n    printasm=0,\n    verbose=0;\n\nstatic void printErrorPos(char *path,int pos,int before,int after) {\n  FILE * file;\n  int i=0,\n      nread,\n      line=0;\n  char buf[2];\n  file = fopen( path , \"r\");  \n  if (file) {\n    while ((nread = fread(buf, 1, 1, file)) > 0) {\n      i+=nread;\n      if (buf[0]=='\\n') line++;\n      if (i>=(pos-before) && i<=(pos+after)) {\n        if (i>pos && buf[0]=='\\n') break;\n        printf(\"%c\",buf[0]);\n      }\n    }\n    fclose(file);\n    printf(\" ( in line %d )\\n\",line);\n  }\n} \n\nstatic int execute(char *path) {\n  FILE * file;\n  sw1 nread,pos;\n  uw1 cstop0=cstop;\n  file = fopen( path , \"r\");  \n  if (file) {\n    while ((nread = fread(&CS[cstop], 1, 1024, file)) > 0) {\n      cstop+=(uw1)nread;\n    }\n    CS[cstop]=0;\n    cstop++;\n    fclose(file);\n    printf(\"%s [%d]\\n\",path,cstop);\n    pos=pctop=(sw1)cstop0;\n#if COMPILEINCR==1\n    pos=compile(CS,pos,(uw1*)&pctop,0);\n#else\n    pos=compile(CS,pos,(uw1*)&pctop);\n#endif\n    if (vmerror!=EOK) {\n      printf(\"Compilation failed with error %d (%s) at character position %d\\n\",vmerror,VMERRORNAME[vmerror],-pos);\n      printErrorPos(path,-pos,5,5);\n      return -1;\n    }\n    printf(\"Code size: %d Byte(s)\\n\",pctop);    \n    pctop=0;\n    vmstate=0;\n    while (vmstate!=VMEND && !vmerror) pctop=vmloop(CS,(uw1)pctop,1000);\n    printf(\"END pc=%x state=%x ds=%d rs=%d fs=%d err=%d\\n\",pctop,vmstate,dstop,rstop,fstop,vmerror);\n    if (vmerror)  printf(\"Exeuction failed with error %d (%s).\\n\",vmerror,VMERRORNAME[vmerror]);\n    return vmerror;\n  } else {\n    printf(\"Error opening file %s\\n\",path);\n    return -1;\n  }\n}\n\nstatic int diss(char *path) {\n  FILE * file;\n  int nread;\n  sw1 pos;\n  cstop=0;\n  file = fopen( path , \"r\");  \n  if (file) {\n    while ((nread = fread(&CS[cstop], 1, 1024, file)) > 0) {\n      cstop+=(uw1)nread;\n    }\n    printf(\"%s [%d]\\n\",path,cstop);\n    pos=0;\n    pctop=0;\n#if COMPILEINCR==1\n    pos=compile(CS,pos,(uw1*)&pctop,0);\n#else\n    pos=compile(CS,pos,(uw1*)&pctop);\n#endif\n    if (vmerror!=EOK) {\n      printf(\"Compilation failed with error %d (%s) at character position %d\\n\",vmerror,VMERRORNAME[vmerror],-pos);\n      printErrorPos(path,-pos,5,5);\n      return -1;\n    }\n    printf(\"Code size %d Bytes\\n\",pctop);\n    return disassemble(0,(ub2)(pctop-1));\n  } else {\n    printf(\"Error opening file %s\\n\",path);\n    return -1;\n  }\n}\n\nstatic int profileVM(char *path) {\n  FILE * file;\n  int i,\n      runs=1000000,\n      nread,pos,off=0,\n      words=diss(path);\n  char *buf=malloc(10000);\n  cstop=0;\n  file = fopen( path , \"r\");\n  ub4 start = vmMilli();\n  if (file) {\n    while ((nread = fread(&buf[off], 1, 1024, file)) > 0) {\n      off+=nread;\n    }\n    for(i=0;i<runs;i++) {\n      pos=0;\n      pctop=0;\n      cstop=(uw1)off;\n      memcpy(CS,buf,off+1);\n#if COMPILEINCR==1\n      pos=compile(CS,pos,(uw1*)&pctop,0);\n#else\n      pos=compile(CS,pos,(uw1*)&pctop);\n#endif\n      if (vmerror) return -1;      \n    }\n  }\n  ub4 stop = vmMilli();\n  printf(\"%d nanosec/compiled word\\n\",((stop-start)*1000)/(runs/1000*words));\n  return 0;\n}\n\n// ( -- a b ) \nstatic sb4 myRandom2() {\n  sb2 a=-2000,b=-100;\n  return (sb4)(((ub2)a<<16)+(ub2)b);\n}\n// ( -- a b ) \nstatic sb4 myRandomDouble() {\n  sb4 a=-123456;\n  return a;\n}\n\n\nint main(int argc, char *argv[]) {\n  int disass=0,i;\n  int status=0;\n  char *file=NULL;\n  cstop=0;\n  pctop=0;\n  \n  iosInit();\n  fiosAdd(\"milli\",IOSCALLBACK(vmMilli),0,0,4);\n  fiosAdd(\"random2\",IOSCALLBACK(myRandom2),0,0,4);\n  fiosAdd(\"2random\",IOSCALLBACK(myRandomDouble),0,0,4);\n#if DSP==1\n  // DSP Math\n  FPRELUINIT;\n  FPSININIT;\n  FPLOG10INIT;\n  FPSIGMOIDINIT;\n  FPVECINIT;\n#endif\n  \n  for(i=0;i<8192;i++) mySample[i]=i;\n  diosAdd(\"data2\",IOSDATA(myData2),100,2);\n  diosAdd(\"data1\",IOSDATA(myData1),100,1);\n  diosAdd(\"sample\",IOSDATA(mySample),8192,2);\n  diosAdd(\"counter\",IOSDATA(&myCounter),0,2);\n  for(i=1;i<argc;i++) {\n    if (strcmp(argv[i],\"-t\")==0) test=1; \n    if (strcmp(argv[i],\"-v\")==0) verbose++; \n    if (strcmp(argv[i],\"-p\")==0) profile=1;\n    if (strcmp(argv[i],\"-d\")==0) printasm=1;\n    if (argv[i][0]!='-') file=argv[i];\n  }\n  if (file!=NULL) {\n    if (printasm) \n      status = diss(file);\n    else if (profile)\n      status = profileVM(file);\n    else\n      status = execute(file); \n  } \n#if READLINE==1\n  else {\n    char *line=\"\";\n    uw1 cstop0=cstop,len;\n    sw1 pos;\n    while (line) {\n      line=readline(\"> \");\n      if (line) {\n        add_history(line);\n        len=strlen(line);\n        pos=pctop=(sw1)cstop0;\n        memcpy(&CS[cstop0],line,len+1);\n        cstop=cstop0+len;\n        // printf(\"<%s>\\n\",&CS[cstop0]);\n        // printf(\"cstop0:%d\\n\",cstop0);\n    #if COMPILEINCR==1\n        pos=compile(CS,pos,(uw1*)&pctop,0);\n    #else\n        pos=compile(CS,pos,(uw1*)&pctop);\n    #endif\n        if (vmerror!=EOK) {\n          printf(\"Compilation failed with error %d (%s) at character position %d\\n\",vmerror,VMERRORNAME[vmerror],cstop0-pos);\n          continue;\n        }\n        vmstate=0;\n        if (verbose) disassemble(0,(ub2)(pctop-1));\n        pctop=(sw1)cstop0;\n        // Global word definition added?\n        if (vmcslocked>0) cstop0=(uw1)vmcslocked;\n        while (vmstate!=VMEND && !vmerror) pctop=vmloop(CS,(uw1)pctop,1000);\n        if (verbose) printf(\"END pc=%x state=%x ds=%d rs=%d fs=%d err=%d\\n\",pctop,vmstate,dstop,rstop,fstop,vmerror);\n        if (vmerror)  printf(\"Exeuction failed with error %d (%s).\\n\",vmerror,VMERRORNAME[vmerror]);\n      }\n    }\n    printf(\"\\nExit.\\n\");\n  }\n#endif\n#if DICTLINEAR!=1\n  if (verbose) {\n    printf(\"VM Dictionary Collisions: %d\\n\",dictcollision);\n  }\n#endif\n  return status;\n}"},"header":{}}},"dsp":{"source":{"fplog10.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"vm.h\"\n#include \"vmio.h\"\n#include \"fplog10.h\"\n\nstatic ub1 log10lut[] = {\n0, // x=10\n4, // x=11\n7, // x=12\n11, // x=13\n14, // x=14\n17, // x=15\n20, // x=16\n23, // x=17\n25, // x=18\n27, // x=19\n30, // x=20\n32, // x=21\n34, // x=22\n36, // x=23\n38, // x=24\n39, // x=25\n41, // x=26\n43, // x=27\n44, // x=28\n46, // x=29\n47, // x=30\n49, // x=31\n50, // x=32\n51, // x=33\n53, // x=34\n54, // x=35\n55, // x=36\n56, // x=37\n57, // x=38\n59, // x=39\n60, // x=40\n61, // x=41\n62, // x=42\n63, // x=43\n64, // x=44\n65, // x=45\n66, // x=46\n67, // x=47\n68, // x=48\n69, // x=49\n69, // x=50\n70, // x=51\n71, // x=52\n72, // x=53\n73, // x=54\n74, // x=55\n74, // x=56\n75, // x=57\n76, // x=58\n77, // x=59\n77, // x=60\n78, // x=61\n79, // x=62\n79, // x=63\n80, // x=64\n81, // x=65\n81, // x=66\n82, // x=67\n83, // x=68\n83, // x=69\n84, // x=70\n85, // x=71\n85, // x=72\n86, // x=73\n86, // x=74\n87, // x=75\n88, // x=76\n88, // x=77\n89, // x=78\n89, // x=79\n90, // x=80\n90, // x=81\n91, // x=82\n91, // x=83\n92, // x=84\n92, // x=85\n93, // x=86\n93, // x=87\n94, // x=88\n94, // x=89\n95, // x=90\n95, // x=91\n96, // x=92\n96, // x=93\n97, // x=94\n97, // x=95\n98, // x=96\n98, // x=97\n99, // x=98\n99, // x=99\n};\n\n// x-scale is 1:10 and log10-scale is 1:100\nsb2 fplog10(sb2 x) {\n  sb2 shift=0;\n  while (x>=100) { shift++; x/=10; };\n  return shift*100+(sb2)log10lut[x-10];\n}","fprelu.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"vm.h\"\n#include \"vmio.h\"\n#include \"fprelu.h\"\n\nsb2 fprelu(sb2 i) {\n  return i<0?0:i;\n}","fpsigmoid.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"vm.h\"\n#include \"vmio.h\"\n#include \"fplog10.h\"\n#include \"fpsigmoid.h\"\n\n\nstatic ub1 sglut13[] = { 0,\n  9,\n  19,\n  28,\n  37,\n  54,\n  63,\n  71,\n  78,\n  93,\n  101,\n  114,\n  120,\n  133,\n  144,\n  149,\n  159,\n  169,\n  177,\n  189,\n  199,\n  206,\n  211,\n  219 \n};\nstatic ub1 sglut310[] = { 0, 8, 30, 42, 46, 47 };\n\n// y scale 1:1000 [0,1], x scale 1:1000\nsb2 fpsigmoid(sb2 x) {\n  sb2 y;\n  ub1 mirror=x<0?1:0;\n  if (mirror) x=-x;\n  if (x>=10000) return mirror?0:1000;\n  if (x<=1000) {\n    y = 500+(((x*231)/1000));\n    return mirror?1000-y:y;\n  } else if (x<3000) {\n    ub2 i10 = ((fplog10((x/5)|0)/2))-65;\n    y = ((sb2)sglut13[i10])+731;\n    return mirror?1000-y:y;\n  } else {\n    ub2 i10 = ((fplog10((x/10)|0)/10))-14;\n    y = ((sb2)sglut310[i10])+952;\n    return mirror?1000-y:y;\n  }\n  return 0;\n}\n\n","fpsin.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"vm.h\"\n#include \"vmio.h\"\n#include \"fpsin.h\"\n\n// https://www.nullhardware.com/blog/fixed-point-sine-and-cosine-for-embedded-systems/\n// x-scale: 1:1000 (0-6283 <=> 0-2PI), y-scale:1:1000 (-1000/+1000 <=> -1/+1)\nsb2 fpsin(sb2 i)\n{  \n    // x-scale input 6282 -> 4*8192=32768 == 2PI \n    i=(sb2)(((sb4)i*5215l)/1000l);\n    /* Convert (signed) input to a value between 0 and 8192. (8192 is pi/2, which is the region of the curve fit). */\n    /* ------------------------------------------------------------------- */\n    i <<= 1;\n    ub1 c = i<0; //set carry for output pos/neg\n\n    if(i == (i|0x4000)) // flip input value to corresponding value in range [0..8192)\n        i = (1<<15) - i;\n    i = (i & 0x7FFF) >> 1;\n    /* ------------------------------------------------------------------- */\n\n    /* The following section implements the formula:\n     = y * 2^-n * ( A1 - 2^(q-p)* y * 2^-n * y * 2^-n * [B1 - 2^-r * y * 2^-n * C1 * y]) * 2^(a-q)\n    Where the constants are defined as follows:\n    */\n    enum {A1=3370945099UL, B1=2746362156UL, C1=292421UL};\n    enum {n=13, p=32, q=31, r=3, a=12};\n\n    ub4 y = (C1*((ub4)i))>>n;\n    y = B1 - (((ub4)i*y)>>r);\n    y = (ub4)i * (y>>n);\n    y = (ub4)i * (y>>n);\n    y = A1 - (y>>(p-q));\n    y = (ub4)i * (y>>n);\n    y = (y+(1UL<<(q-a-1)))>>(q-a); // Rounding\n\n    // y-scale -1/+1 -> -1000/+1000\n    return c ? (sb2)(-(y*250)/1024) : (sb2)((y*250)/1024);\n}\n","fpvec.c":"#include \"config.h\"\n#include \"standard.h\"\n#include \"vm.h\"\n#include \"vmio.h\"\n#include \"fpvec.h\"\n\n// src: IOS -(index+1) or CS offset, dst: CS offset\nvoid vecload(sb2 src, sb2 srcoff, sb2 dst) {\n  sb2 *psrc=NULL,*pdst=NULL;\n  ub2 srclen=0,dstlen=0;\n  // printf(\"vecload (%x) (%x)\\n\",src,dst);\n  if (dst<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pdst=(sb2*)&CS[dst]; \n    dstlen=*((sb2*)&CS[dst-2]);\n  };\n  if (src<0) { \n    // IOS Data\n    src=-src-1; \n    if (src>=IOSIZE || ios[src].type!='D' || ios[src].size!=2) return vmraiseerror(EDATA); \n    psrc=DIOSDATADPTR(sb2,src)+srcoff;\n    srclen=ios[src].cells;\n  } else {\n    // CS array\n    psrc=(sb2*)&CS[src];\n    srclen=*((sb2*)&CS[src-2]);\n  }\n  if (srclen<dstlen) return vmraiseerror(EDATA);\n  memcpy(pdst,psrc,dstlen*2);\n  // printf(\"vecload $%x[%d]+%d $%x[%d]\\n\",psrc,srclen,srcoff,pdst,dstlen);\n};\n\n// src: CS offset, dst: CS offset\nvoid vecscale(sb2 src, sb2 dst, sb2 k) {\n  ub2 index;\n  sb2 ks=0;\n  sb2 *psrc=NULL,*pdst=NULL, *pk=NULL;\n  ub2 srclen=0,dstlen=0,klen=0;\n  // printf(\"vecscale (%x) (%x) (%x)\\n\",src,dst,k);\n  if (src<0) return vmraiseerror(EDATA); else { \n    // CS array\n    psrc=(sb2*)&CS[src]; \n    srclen=*((sb2*)&CS[src-2]);\n  };\n  if (dst<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pdst=(sb2*)&CS[dst]; \n    dstlen=*((sb2*)&CS[dst-2]);\n  };\n  if (k<0) {ks=-k;} else if (k!=0) { \n    // CS array\n    pk=(sb2*)&CS[k]; \n    klen=*((sb2*)&CS[k-2]);\n  };\n  if (srclen<dstlen || (klen && klen!=dstlen)) return vmraiseerror(EDATA);\n  if (ks==0) {\n    for(index=0;index<dstlen;index++) {\n      ks=pk[index];\n      if (ks<0) pdst[index]=psrc[index]/(-ks);\n      else      pdst[index]=psrc[index]*ks;\n    }; \n  } else {\n    // constant down-scaling\n    for(index=0;index<dstlen;index++) {\n      pdst[index]=psrc[index]/ks;\n    }; \n  }\n  // printf(\"vecscale $%x[%d] $%x[%d] $%x[%d]\\n\",psrc,srclen,pdst,dstlen,pk,klen);\n};\n\n\n// src: CS offset (array), dst: CS offset (array), k: CS offset (array), |k|=|dst|\nvoid vecfold(sb2 src, sb2 weights, sb2 dst, sb2 k) {\n  ub2 index,j,wo;\n  sb4 ks=0;\n  sb4 t;\n  sb2 *psrc=NULL,*pweights, *pdst=NULL, *pk=NULL;\n  ub2 srclen=0,weightslen=0,dstlen=0,klen=0;\n  // printf(\"vecfold (%x) (%x) (%x) (%x)\\n\",src,weights,dst,k);\n  if (src<0) return vmraiseerror(EDATA); else { \n    // CS array\n    psrc=(sb2*)&CS[src]; \n    srclen=*((sb2*)&CS[src-2]);\n  };\n  if (weights<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pweights=(sb2*)&CS[weights]; \n    weightslen=*((sb2*)&CS[weights-2]);\n  };\n  if (dst<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pdst=(sb2*)&CS[dst]; \n    dstlen=*((sb2*)&CS[dst-2]);\n  };\n  if (k<0) {ks=-k;}  else if (k!=0) { \n    // CS array\n    pk=(sb2*)&CS[k]; \n    klen=*((sb2*)&CS[k-2]);\n  };\n  // printf(\"vecfold src $%x[%d] weights $%x[%d] dst $%x[%d] k $%x[%d]\\n\",psrc,srclen,pweights,weightslen,pdst,dstlen,pk,klen);\n  if (srclen*dstlen!=weightslen || (klen && klen != dstlen)) return vmraiseerror(EDATA);\n  wo=0;\n  for(index=0;index<dstlen;index++) {\n    t=0;\n    for(j=0;j<srclen;j++) {\n      t=t+(pweights[wo+j]*psrc[j]);\n    }\n    if (pk) {\n      ks=(sb4)pk[index];\n      if (ks<0) pdst[index]=(sb2)(t/(-ks));\n      else      pdst[index]=(sb2)(t*ks);\n    } else if (ks) {\n      pdst[index]=(sb2)(t/ks);\n    } else {\n      pdst[index]=(sb2)t;\n    };\n    wo += srclen;\n  };\n};\n\n// src: CS offset, dst: CS offset, k: here scalar for all dst array elements!\n// if kwidth < 0 then weights is pooling layer paramater: kheight | 256: min, 512:max, 1024:mean\nvoid vecconv(sb2 src, sb2 weights, sb2 dst, sb2 sk, sb2 swidth, sb2 kwidth, sb2 stride, sb2 pad) {\n  sb2 x,y,i,j,k,l,q,r,n,index,wo,pooling=0;\n  sb4 ks;\n  sb4 t,v;\n  sb2 *psrc=NULL,*pweights, *pdst=NULL;\n  ub2 srclen=0,weightslen=0,dstlen=0,klen=0,kheight,sheight,dwidth,dheight;\n  // printf(\"vecfold (%x) (%x) (%x) (%x)\\n\",src,weights,dst,k);\n  // printf(\"weights=%d kwidth=%d\\n\",weights,kwidth);\n  if (src<0) return vmraiseerror(EDATA); else { \n    // CS array\n    psrc=(sb2*)&CS[src]; \n    srclen=*((sb2*)&CS[src-2]);\n  };\n  if (kwidth>0) {\n    // convolution\n    if (weights<0) return vmraiseerror(EDATA); else { \n      // CS array\n      pweights    = (sb2*)&CS[weights]; \n      weightslen  = *((sb2*)&CS[weights-2]);\n      kheight     = weightslen/(ub2)kwidth;\n   }\n  } else {\n    // pooling\n    pooling = weights>>8;\n    kwidth  = -kwidth;\n    kheight = weights&255;\n    pweights = 0;\n    weightslen = kwidth * kheight; \n  }\n  if (dst<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pdst=(sb2*)&CS[dst]; \n    dstlen=*((sb2*)&CS[dst-2]);\n  };\n  // if (srclen*dstlen!=weightslen || (klen && klen != dstlen)) return vmraiseerror(EDATA);\n\n  sheight = srclen/swidth;\n  // TODO TBC\n  dwidth  = (swidth+pad*2-kwidth)/stride+(kwidth%2==0?0:1);\n  dheight = (sheight+pad*2-kheight)/stride+(kheight%2==0?0:1);\n\n#if FPDEBUG>1\n  printf(\"vecconv src $%x[%d] weights $%x[%d] dst $%x[%d] swidth=%d sheight=%d kwidth=%d kheight=%d dwidth=%d dheight=%d sk=%d stride=%d pad=%d \\n\",\n         psrc,srclen,pweights,weightslen,pdst,dstlen,swidth,sheight,kwidth,kheight,dwidth,dheight,sk,stride,pad);\n#endif\n\n  if ((kwidth*kheight)!=weightslen) return vmraiseerror(EDATA);\n  if ((dwidth*dheight)>dstlen) return vmraiseerror(EDATA);\n  \n  x=-pad;\n  // i and j are detsination column and row index\n  if (!pooling) {\n    // convolution operation\n    for(i=0;i<dwidth;i++) {\n      y=-pad;\n      for(j=0;j<dheight;j++) {\n        t=0;\n        for (l=0;l<kheight;l++) {\n          for(k=0;k<kwidth;k++) {\n            if ((x+k)<0 || (y+l)<0 || (x+k)>=swidth || (y+l)>=sheight) continue;\n            // source array index\n            index=(x+k)+(y+l)*swidth;\n            // printf(\"%d %d %d %d srcindex=%d\\n\",i,j,k,l,index);\n            t=t+(pweights[l*kwidth+k]*psrc[index]);\n          }\n        }\n        // destination array index\n        index=(j*dwidth)+i;\n        // printf(\"%d %d dstindex=%d\\n\",i,j,index);\n        if (sk!=0) {\n          ks=(sb4)sk;\n          if (ks<0) pdst[index]=(sb2)(t/(-ks));\n          else      pdst[index]=(sb2)(t*ks);\n        } else {\n          pdst[index]=(sb2)t;\n        };\n        y+=stride;\n      }\n      x+=stride;\n    };\n  } else {\n    // pooling operation\n    for(i=0;i<dwidth;i++) {\n      y=-pad;\n      for(j=0;j<dheight;j++) {\n        n=0;\n        for (l=0;l<kheight;l++) {\n          for(k=0;k<kwidth;k++) {\n            if ((x+k)<0 || (y+l)<0 || (x+k)>=swidth || (y+l)>=sheight) continue;\n            // source array index\n            index=(x+k)+(y+l)*swidth;\n            // printf(\"%d %d %d %d srcindex=%d\\n\",i,j,k,l,index);\n            v=psrc[index];\n            if (n==0) {\n              t=v;\n            } else switch (pooling) {\n              case OPMIN: t=v<t?v:t; break;\n              case OPMAX: t=v>t?v:t; break;\n              case OPAVG: \n              case OPSUM: t+=v; break;\n            }\n            n++;          \n          }\n        }\n        // destination array index\n        index=(j*dwidth)+i;\n        switch (pooling) {\n          case OPAVG: t/=n; break;\n        }\n        // printf(\"%d %d dstindex=%d\\n\",i,j,index);\n        if (sk!=0) {\n          ks=(sb4)sk;\n          if (ks<0) pdst[index]=(sb2)(t/(-ks));\n          else      pdst[index]=(sb2)(t*ks);\n        } else {\n          pdst[index]=(sb2)t;\n        };\n        y+=stride;\n      }\n      x+=stride;\n    };  \n  }\n};\n\n// src: CS offset, dst: CS offset\nvoid vecmap(sb2 src, sb2 dst, sb2 func, sb2 k) {\n  ub2 index;\n  sb2 ks=0;\n  sb2 t;\n  sb2 *psrc=NULL, *pdst=NULL, *pk=NULL;\n  void *pfunc=NULL;\n  sb2  findex;\n  ub2 srclen=0,dstlen=0,klen=0;\n  \n  // printf(\"vecmap (%x) (%x) (%x:%d) (%x)\\n\",src,dst,func,func,k);\n  if (src<0) return vmraiseerror(EDATA); else { \n    // CS array\n    psrc=(sb2*)&CS[src]; \n    srclen=*((sb2*)&CS[src-2]);\n  };\n  if (dst<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pdst=(sb2*)&CS[dst]; \n    dstlen=*((sb2*)&CS[dst-2]);\n  };\n  if (func < 0) {\n    // IOS func index\n    findex=-func-1;\n    if (ios[findex].type!='F') return vmraiseerror(EDATA);\n    pfunc=ios[findex].callback;\n  } else {\n    // Forth word CS\n    // Not supported yet\n    return vmraiseerror(EDATA);\n  }\n  if (k<0) { ks=-k; } else if (k!=0) { \n    // CS array\n    pk=(sb2*)&CS[k]; \n    klen=*((sb2*)&CS[k-2]);\n  };\n  if (pk) {\n    for(index=0;index<dstlen;index++) {\n      ks=pk[index];\n      t=FIOSCALL2(findex,psrc[index]);\n      if (ks<0) pdst[index]=(sb2)(t/(-ks));\n      else      pdst[index]=(sb2)(t*ks);\n    };\n   } else if (ks) {\n    for(index=0;index<dstlen;index++) {\n      t=FIOSCALL2(findex,psrc[index]);\n      pdst[index]=(sb2)(t/ks);\n    };   \n   } else {\n    for(index=0;index<dstlen;index++) {\n      pdst[index]=FIOSCALL2(findex,psrc[index]);\n    };\n  } \n  // printf(\"vecmap src $%x[%d] dst $%x[%d] func $%x k $%x[%d]\\n\",psrc,srclen,pdst,dstlen,pfunc,pk,klen);\n};\n\n// src: CS offset, dst: CS offset\nvoid vecadd(sb2 op1, sb2 op2, sb2 dst, sb2 k) {\n  ub2 index;\n  sb4 ks=0;\n  sb4 t;\n  sb2 *pop1=NULL,*pop2=NULL,*pdst=NULL, *pk=NULL;\n  ub2 op1len=0,op2len=0,dstlen=0,klen=0;\n  // printf(\"vecadd (%x) (%x) (%x) (%x)\\n\",op1,op2,dst,k);\n  if (op1<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pop1=(sb2*)&CS[op1]; \n    op1len=*((sb2*)&CS[op1-2]);\n  };\n  if (op2<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pop2=(sb2*)&CS[op2]; \n    op2len=*((sb2*)&CS[op2-2]);\n  };\n  if (dst<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pdst=(sb2*)&CS[dst]; \n    dstlen=*((sb2*)&CS[dst-2]);\n  };\n  if (k<0) { ks=-k; } else if (k!=0) { \n    // CS array\n    pk=(sb2*)&CS[k]; \n    klen=*((sb2*)&CS[k-2]);\n  };\n  if (op1len!=op2len) return vmraiseerror(EDATA);\n  if (dstlen>op1len) dstlen=op1len;\n  if (k!=0 && klen<dstlen) return vmraiseerror(EDATA);\n  if (pk) {\n    for(index=0;index<dstlen;index++) {\n      ks=(sb4)pk[index];\n      t=(sb4)pop1[index]+(sb4)pop2[index];\n      if (ks<0) pdst[index]=(sb2)(t/(-ks));\n      else      pdst[index]=(sb2)(t*ks);\n    };\n   } else if (ks) {\n    for(index=0;index<dstlen;index++) {\n      t=(sb4)pop1[index]+(sb4)pop2[index];\n      pdst[index]=(sb2)(t/ks);\n    };   \n   } else {\n    for(index=0;index<dstlen;index++) {\n      pdst[index]=pop1[index]+pop2[index];\n    };\n  } \n  // printf(\"vecadd $%x[%d] $%x[%d] $%x[%d] $%x[%d]\\n\",pop1,op1len,pop2,op2len,pdst,dstlen,pk,klen);\n};\n\n// src: CS offset, dst: CS offset\nvoid vecmul(sb2 op1, sb2 op2, sb2 dst, sb2 k) {\n  ub2 index;\n  sb4 ks=0;\n  sb4 t;\n  sb2 *pop1=NULL,*pop2=NULL,*pdst=NULL, *pk=NULL;\n  ub2 op1len=0,op2len=0,dstlen=0,klen=0;\n  // printf(\"vecmul (%x) (%x) (%x) (%x)\\n\",op1,op2,dst,k);\n  if (op1<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pop1=(sb2*)&CS[op1]; \n    op1len=*((sb2*)&CS[op1-2]);\n  };\n  if (op2<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pop2=(sb2*)&CS[op2]; \n    op2len=*((sb2*)&CS[op2-2]);\n  };\n  if (dst<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pdst=(sb2*)&CS[dst]; \n    dstlen=*((sb2*)&CS[dst-2]);\n  };\n  if (k<0) { ks=-k; /* applied to all elements, only reduction*/ } else if (k!=0) { \n    // CS array\n    pk=(sb2*)&CS[k]; \n    klen=*((sb2*)&CS[k-2]);\n  };\n  if (op1len!=op2len) return vmraiseerror(EDATA);\n  if (dstlen>op1len) dstlen=op1len;\n  if (k!= 0 && klen<dstlen) return vmraiseerror(EDATA);\n  if (pk) {\n    for(index=0;index<dstlen;index++) {\n      ks=(sb4)pk[index];\n      t=(sb4)pop1[index]*(sb4)pop2[index];\n      if (ks<0) pdst[index]=(sb2)(t/(-ks));\n      else      pdst[index]=(sb2)(t*ks);\n    };\n  } else if (ks) {\n    for(index=0;index<dstlen;index++) {\n      t=(sb4)pop1[index]*(sb4)pop2[index];\n      pdst[index]=(sb2)(t/ks);\n    };   \n  } else {\n    for(index=0;index<dstlen;index++) {\n      pdst[index]=pop1[index]*pop2[index];\n    };\n  } \n  // printf(\"vecmul $%x[%d] $%x[%d] $%x[%d] $%x[%d]\\n\",pop1,op1len,pop2,op2len,pdst,dstlen,pk,klen);\n};\n\n// ( vec vecoff len op -- index min )\n// op: OPMIN, OPMAX, OPAVG, OPSUM\nsb4 vecreduce  (sb2 vec, sb2 vecoff, sb2 len, sb2 op) {\n  ub2 index;\n  sb2 *pvec=NULL;\n  sb2 accu=0;\n  sb2 veclen;\n  sb4 accu4=0;\n  \n  if (vec<0) { \n    // IOS Data\n    vec=-vec-1; \n    if (vec>=IOSIZE || ios[vec].type!='D' || ios[vec].size!=2) { vmraiseerror(EDATA); return 0; } \n    pvec=DIOSDATADPTR(sb2,vec)+vecoff;\n    veclen=(sb2)ios[vec].cells;\n  } else { \n    // CS array\n    pvec=(sb2*)&CS[vec]; \n    veclen=*((sb2*)&CS[vec-2]);\n  };\n  if (pvec && len<=veclen) {\n    index=(ub2)vecoff;\n    if (len==0) len=veclen;\n    switch (op) {\n      case OPMIN: \n        accu=pvec[index++];\n        for(;index<len;index++) {\n          accu=pvec[index]<accu?pvec[index]:accu;\n        }\n        break;\n      case OPMAX:  \n        accu=pvec[index++];\n        for(;index<len;index++) {\n          accu=pvec[index]>accu?pvec[index]:accu;\n        }\n        break;\n      case OPAVG:\n      case OPSUM: \n        accu4=0;\n        for(;index<len;index++) {\n          accu4+=(sb4)pvec[index];\n        }\n        if (op==OPAVG) accu4/=len;\n        return accu4;\n        break;\n    }\n  } else return 0;\n  // Encode two return values (index, value)\n  return (sb4)(((ub2)index<<16)+(ub2)accu);\n};\n\n// src: CS offset, dst: CS offset\nvoid vecreshape(sb2 src,sb2 dst, sb2 k) {\n  ub2 index,index2;\n  sb2 *psrc=NULL,*pdst=NULL;\n  ub2 srclen=0,dstlen=0,newlen=0;\n  // printf(\"vecadd (%x) (%x) (%x) (%x)\\n\",op1,op2,dst,k);\n  if (src<0) return vmraiseerror(EDATA); else { \n    // CS array\n    psrc=(sb2*)&CS[src]; \n    srclen=*((sb2*)&CS[src-2]);\n  };\n  if (dst<0) return vmraiseerror(EDATA); else { \n    // CS array\n    pdst=(sb2*)&CS[dst]; \n    dstlen=*((sb2*)&CS[dst-2]);\n  };\n  if (k<0) {\n    // shrink\n    k=-k;\n    newlen=srclen/k;\n    if (newlen>dstlen) return vmraiseerror(EDATA);\n    for(index=0;index<newlen;index++) {\n      pdst[index]=psrc[index/k];\n    }\n  } else if (k>0) {\n    // expand\n    newlen=srclen*k;\n    if (newlen>dstlen) return vmraiseerror(EDATA);\n    for(index=0;index<newlen;index++) {\n      for(index2=0;index2<k;index2++)\n        pdst[index2]=psrc[index*k];\n    }\n  }\n};\nvoid vecprint  (sb2 vec) {\n  ub2 index;\n  sb2 *pvec=NULL;\n  sb2 veclen=0;\n  if (vec<0) { \n    // IOS Data\n    vec=-vec-1; \n    if (vec>=IOSIZE || ios[vec].type!='D' || ios[vec].size!=2) return vmraiseerror(EDATA); \n    pvec=DIOSDATADPTR(sb2,vec);\n    veclen=(sb2)ios[vec].cells;\n  } else { \n    // CS array\n    pvec=(sb2*)&CS[vec]; \n    veclen=*((sb2*)&CS[vec-2]);\n  };\n  if (pvec) {\n    for(index=0;index<veclen;index++) {\n      CONSOLEFMT(\" %d \",(sb4)pvec[index]);\n    }\n  }\n};"},"header":{"fplog10.h":"#ifndef _FPLOG10_H\n#define _FPLOG10H_\n\n// x-scale is 1:10 and log10-scale is 1:100\nextern sb2 fplog10(sb2 x);\n\n#define FPLOG10INIT fiosAdd(\"log\",IOSCALLBACK(fplog10),1,2,2);\n\n#endif\n","fprelu.h":"#ifndef _FPRELU_H\n#define _FPRELU_H\n// x-scale: 1:1000 (0-6283 <=> 0-2PI), y-scale:1:1000 (-1000/+1000 <=> -1/+1)\nextern sb2 fprelu(sb2 i);\n\n#define FPRELUINIT fiosAdd(\"relu\",IOSCALLBACK(fprelu),1,2,2)\n\n#endif","fpsigmoid.h":"#ifndef _FPSIGMOID_H\n#define _FPSIGMOID_H\n\n // y scale 1:1000 [0,1], x scale 1:1000\nextern sb2 fpsigmoid(sb2 x);\n\n#define FPSIGMOIDINIT   fiosAdd(\"sigmoid\",IOSCALLBACK(fpsigmoid),1,2,2)\n\n#endif\n","fpsin.h":"#ifndef _FPSIN_H\n#define _FPSIN_H\n// x-scale: 1:1000 (0-6283 <=> 0-2PI), y-scale:1:1000 (-1000/+1000 <=> -1/+1)\nextern sb2 fpsin(sb2 i);\n\n#define FPSININIT fiosAdd(\"sin\",IOSCALLBACK(fpsin),1,2,2)\n\n#endif\n","fpvec.h":"#ifndef _FPVEC_H\n#define _FPVEC_H\n\nextern void vecload (sb2 src, sb2 srcoff, sb2 dst);\nextern void vecscale(sb2 src, sb2 dst, sb2 k);\nextern void vecfold (sb2 src, sb2 weights, sb2 dst, sb2 k);\nextern void vecconv(sb2 src, sb2 weights, sb2 dst, sb2 k, sb2 swidth, sb2 kwidth, sb2 stride, sb2 pad);\nextern void vecmap  (sb2 src, sb2 dst, sb2 func, sb2 k);\nextern void vecadd  (sb2 op1, sb2 op2, sb2 dst, sb2 k);\nextern void vecmul  (sb2 op1, sb2 op2, sb2 dst, sb2 k);\nextern sb4  vecreduce(sb2 vec, sb2 off, sb2 len, sb2 op);\nextern void vecreshape (sb2 src, sb2 dst, sb2 k);\nextern void vecprint(sb2 vec);\n\n#define OPMIN 1 // 256\n#define OPMAX 2 // 512\n#define OPAVG 4 // 1024\n#define OPSUM 8 // 2048\n\n#define FPVECINIT   fiosAdd(\"vecload\",IOSCALLBACK(vecload),3,2,0);\\\n  fiosAdd(\"vecscale\",IOSCALLBACK(vecscale),3,2,0);\\\n  fiosAdd(\"vecfold\",IOSCALLBACK(vecfold),4,2,0);\\\n  fiosAdd(\"vecconv\",IOSCALLBACK(vecconv),8,2,0);\\\n  fiosAdd(\"vecmap\",IOSCALLBACK(vecmap),4,2,0);\\\n  fiosAdd(\"vecadd\",IOSCALLBACK(vecadd),4,2,0);\\\n  fiosAdd(\"vecmul\",IOSCALLBACK(vecmul),4,2,0);\\\n  fiosAdd(\"vecreduce\",IOSCALLBACK(vecreduce),4,2,4);\\\n  fiosAdd(\"vecreshape\",IOSCALLBACK(vecreshape),3,2,0);\\\n  fiosAdd(\"vecprint\",IOSCALLBACK(vecprint),1,2,0);\\\n#endif\n"}},"include":["sys/time.h"]}}